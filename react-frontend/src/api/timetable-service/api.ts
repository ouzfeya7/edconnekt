/* tslint:disable */
/* eslint-disable */
/**
 * Timetable Service
 * API REST conforme au cahier des charges avec authentification par en-têtes
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AbsenceCreate
 */
export interface AbsenceCreate {
    /**
     * 
     * @type {string}
     * @memberof AbsenceCreate
     */
    'teacher_id': string;
    /**
     * 
     * @type {string}
     * @memberof AbsenceCreate
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof AbsenceCreate
     */
    'timeslot_id': string;
    /**
     * 
     * @type {string}
     * @memberof AbsenceCreate
     */
    'reason': string;
    /**
     * 
     * @type {AbsenceStatus}
     * @memberof AbsenceCreate
     */
    'status'?: AbsenceStatus;
}


/**
 * 
 * @export
 * @interface AbsenceRead
 */
export interface AbsenceRead {
    /**
     * 
     * @type {string}
     * @memberof AbsenceRead
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AbsenceRead
     */
    'teacher_id': string;
    /**
     * 
     * @type {string}
     * @memberof AbsenceRead
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof AbsenceRead
     */
    'timeslot_id': string;
    /**
     * 
     * @type {string}
     * @memberof AbsenceRead
     */
    'reason': string;
    /**
     * 
     * @type {AbsenceStatus}
     * @memberof AbsenceRead
     */
    'status': AbsenceStatus;
    /**
     * 
     * @type {string}
     * @memberof AbsenceRead
     */
    'created_at': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const AbsenceStatus = {
    Reported: 'REPORTED',
    Validated: 'VALIDATED'
} as const;

export type AbsenceStatus = typeof AbsenceStatus[keyof typeof AbsenceStatus];


/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface LessonCreate
 */
export interface LessonCreate {
    /**
     * 
     * @type {string}
     * @memberof LessonCreate
     */
    'class_id': string;
    /**
     * 
     * @type {string}
     * @memberof LessonCreate
     */
    'subject_id': string;
    /**
     * 
     * @type {string}
     * @memberof LessonCreate
     */
    'teacher_id': string;
    /**
     * 
     * @type {string}
     * @memberof LessonCreate
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof LessonCreate
     */
    'timeslot_id': string;
    /**
     * 
     * @type {string}
     * @memberof LessonCreate
     */
    'room_id': string;
    /**
     * 
     * @type {LessonStatus}
     * @memberof LessonCreate
     */
    'status'?: LessonStatus;
    /**
     * 
     * @type {number}
     * @memberof LessonCreate
     */
    'repeatweekly'?: number;
}


/**
 * 
 * @export
 * @interface LessonRead
 */
export interface LessonRead {
    /**
     * 
     * @type {string}
     * @memberof LessonRead
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LessonRead
     */
    'class_id': string;
    /**
     * 
     * @type {string}
     * @memberof LessonRead
     */
    'subject_id': string;
    /**
     * 
     * @type {string}
     * @memberof LessonRead
     */
    'teacher_id': string;
    /**
     * 
     * @type {string}
     * @memberof LessonRead
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof LessonRead
     */
    'timeslot_id': string;
    /**
     * 
     * @type {string}
     * @memberof LessonRead
     */
    'room_id': string;
    /**
     * 
     * @type {LessonStatus}
     * @memberof LessonRead
     */
    'status': LessonStatus;
    /**
     * 
     * @type {string}
     * @memberof LessonRead
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof LessonRead
     */
    'updated_at': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const LessonStatus = {
    Scheduled: 'SCHEDULED',
    Cancelled: 'CANCELLED',
    Replaced: 'REPLACED'
} as const;

export type LessonStatus = typeof LessonStatus[keyof typeof LessonStatus];


/**
 * 
 * @export
 * @interface LessonUpdate
 */
export interface LessonUpdate {
    /**
     * 
     * @type {string}
     * @memberof LessonUpdate
     */
    'room_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LessonUpdate
     */
    'timeslot_id'?: string | null;
    /**
     * 
     * @type {LessonStatus}
     * @memberof LessonUpdate
     */
    'status'?: LessonStatus | null;
}


/**
 * 
 * @export
 * @interface ReplacementCreate
 */
export interface ReplacementCreate {
    /**
     * 
     * @type {string}
     * @memberof ReplacementCreate
     */
    'lesson_id': string;
    /**
     * 
     * @type {string}
     * @memberof ReplacementCreate
     */
    'new_teacher_id': string;
    /**
     * 
     * @type {string}
     * @memberof ReplacementCreate
     */
    'validated_by': string;
}
/**
 * 
 * @export
 * @interface ReplacementRead
 */
export interface ReplacementRead {
    /**
     * 
     * @type {string}
     * @memberof ReplacementRead
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ReplacementRead
     */
    'lesson_id': string;
    /**
     * 
     * @type {string}
     * @memberof ReplacementRead
     */
    'old_teacher_id': string;
    /**
     * 
     * @type {string}
     * @memberof ReplacementRead
     */
    'new_teacher_id': string;
    /**
     * 
     * @type {string}
     * @memberof ReplacementRead
     */
    'validated_by': string;
    /**
     * 
     * @type {string}
     * @memberof ReplacementRead
     */
    'validated_at'?: string | null;
}
/**
 * 
 * @export
 * @interface RoomCreate
 */
export interface RoomCreate {
    /**
     * 
     * @type {string}
     * @memberof RoomCreate
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof RoomCreate
     */
    'capacity': number;
}
/**
 * 
 * @export
 * @interface RoomRead
 */
export interface RoomRead {
    /**
     * 
     * @type {string}
     * @memberof RoomRead
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof RoomRead
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof RoomRead
     */
    'capacity': number;
}
/**
 * 
 * @export
 * @interface TimeslotCreate
 */
export interface TimeslotCreate {
    /**
     * 
     * @type {string}
     * @memberof TimeslotCreate
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof TimeslotCreate
     */
    'end_time': string;
}
/**
 * 
 * @export
 * @interface TimeslotRead
 */
export interface TimeslotRead {
    /**
     * 
     * @type {string}
     * @memberof TimeslotRead
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TimeslotRead
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof TimeslotRead
     */
    'end_time': string;
}
/**
 * 
 * @export
 * @interface TimetableAuditRead
 */
export interface TimetableAuditRead {
    /**
     * 
     * @type {string}
     * @memberof TimetableAuditRead
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TimetableAuditRead
     */
    'entity_type': string;
    /**
     * 
     * @type {string}
     * @memberof TimetableAuditRead
     */
    'entity_id': string;
    /**
     * 
     * @type {string}
     * @memberof TimetableAuditRead
     */
    'action': string;
    /**
     * 
     * @type {string}
     * @memberof TimetableAuditRead
     */
    'actor_id': string;
    /**
     * 
     * @type {string}
     * @memberof TimetableAuditRead
     */
    'actor_role': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof TimetableAuditRead
     */
    'diff': { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof TimetableAuditRead
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<ValidationErrorLocInner>}
     * @memberof ValidationError
     */
    'loc': Array<ValidationErrorLocInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {
}

/**
 * AbsencesApi - axios parameter creator
 * @export
 */
export const AbsencesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Déclarer une absence (status REPORTED). Rôles: ENSEIGNANT, COORDONNATEUR, ADMIN
         * @summary Create Absence
         * @param {AbsenceCreate} absenceCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAbsenceAbsencesPost: async (absenceCreate: AbsenceCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'absenceCreate' is not null or undefined
            assertParamExists('createAbsenceAbsencesPost', 'absenceCreate', absenceCreate)
            const localVarPath = `/absences/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(absenceCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Supprimer une absence. Rôles: COORDONNATEUR, ADMIN
         * @summary Delete Absence
         * @param {string} absenceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAbsenceAbsencesAbsenceIdDelete: async (absenceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'absenceId' is not null or undefined
            assertParamExists('deleteAbsenceAbsencesAbsenceIdDelete', 'absenceId', absenceId)
            const localVarPath = `/absences/{absence_id}`
                .replace(`{${"absence_id"}}`, encodeURIComponent(String(absenceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Valider une absence (status VALIDATED). Rôle: DIRECTION. Propage le status sur les lessons du créneau.
         * @summary Validate Absence
         * @param {string} absenceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateAbsenceAbsencesAbsenceIdValidatePost: async (absenceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'absenceId' is not null or undefined
            assertParamExists('validateAbsenceAbsencesAbsenceIdValidatePost', 'absenceId', absenceId)
            const localVarPath = `/absences/{absence_id}/validate`
                .replace(`{${"absence_id"}}`, encodeURIComponent(String(absenceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AbsencesApi - functional programming interface
 * @export
 */
export const AbsencesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AbsencesApiAxiosParamCreator(configuration)
    return {
        /**
         * Déclarer une absence (status REPORTED). Rôles: ENSEIGNANT, COORDONNATEUR, ADMIN
         * @summary Create Absence
         * @param {AbsenceCreate} absenceCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAbsenceAbsencesPost(absenceCreate: AbsenceCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AbsenceRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAbsenceAbsencesPost(absenceCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbsencesApi.createAbsenceAbsencesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Supprimer une absence. Rôles: COORDONNATEUR, ADMIN
         * @summary Delete Absence
         * @param {string} absenceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAbsenceAbsencesAbsenceIdDelete(absenceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AbsenceRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAbsenceAbsencesAbsenceIdDelete(absenceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbsencesApi.deleteAbsenceAbsencesAbsenceIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Valider une absence (status VALIDATED). Rôle: DIRECTION. Propage le status sur les lessons du créneau.
         * @summary Validate Absence
         * @param {string} absenceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateAbsenceAbsencesAbsenceIdValidatePost(absenceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AbsenceRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateAbsenceAbsencesAbsenceIdValidatePost(absenceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbsencesApi.validateAbsenceAbsencesAbsenceIdValidatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AbsencesApi - factory interface
 * @export
 */
export const AbsencesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AbsencesApiFp(configuration)
    return {
        /**
         * Déclarer une absence (status REPORTED). Rôles: ENSEIGNANT, COORDONNATEUR, ADMIN
         * @summary Create Absence
         * @param {AbsenceCreate} absenceCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAbsenceAbsencesPost(absenceCreate: AbsenceCreate, options?: RawAxiosRequestConfig): AxiosPromise<AbsenceRead> {
            return localVarFp.createAbsenceAbsencesPost(absenceCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Supprimer une absence. Rôles: COORDONNATEUR, ADMIN
         * @summary Delete Absence
         * @param {string} absenceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAbsenceAbsencesAbsenceIdDelete(absenceId: string, options?: RawAxiosRequestConfig): AxiosPromise<AbsenceRead> {
            return localVarFp.deleteAbsenceAbsencesAbsenceIdDelete(absenceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Valider une absence (status VALIDATED). Rôle: DIRECTION. Propage le status sur les lessons du créneau.
         * @summary Validate Absence
         * @param {string} absenceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateAbsenceAbsencesAbsenceIdValidatePost(absenceId: string, options?: RawAxiosRequestConfig): AxiosPromise<AbsenceRead> {
            return localVarFp.validateAbsenceAbsencesAbsenceIdValidatePost(absenceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AbsencesApi - object-oriented interface
 * @export
 * @class AbsencesApi
 * @extends {BaseAPI}
 */
export class AbsencesApi extends BaseAPI {
    /**
     * Déclarer une absence (status REPORTED). Rôles: ENSEIGNANT, COORDONNATEUR, ADMIN
     * @summary Create Absence
     * @param {AbsenceCreate} absenceCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbsencesApi
     */
    public createAbsenceAbsencesPost(absenceCreate: AbsenceCreate, options?: RawAxiosRequestConfig) {
        return AbsencesApiFp(this.configuration).createAbsenceAbsencesPost(absenceCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Supprimer une absence. Rôles: COORDONNATEUR, ADMIN
     * @summary Delete Absence
     * @param {string} absenceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbsencesApi
     */
    public deleteAbsenceAbsencesAbsenceIdDelete(absenceId: string, options?: RawAxiosRequestConfig) {
        return AbsencesApiFp(this.configuration).deleteAbsenceAbsencesAbsenceIdDelete(absenceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Valider une absence (status VALIDATED). Rôle: DIRECTION. Propage le status sur les lessons du créneau.
     * @summary Validate Absence
     * @param {string} absenceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbsencesApi
     */
    public validateAbsenceAbsencesAbsenceIdValidatePost(absenceId: string, options?: RawAxiosRequestConfig) {
        return AbsencesApiFp(this.configuration).validateAbsenceAbsencesAbsenceIdValidatePost(absenceId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuditApi - axios parameter creator
 * @export
 */
export const AuditApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Journal d\'audit pour un cours. Rôle: DIRECTION
         * @summary Get Lesson Audit
         * @param {string} lessonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLessonAuditLessonsLessonIdAuditGet: async (lessonId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lessonId' is not null or undefined
            assertParamExists('getLessonAuditLessonsLessonIdAuditGet', 'lessonId', lessonId)
            const localVarPath = `/lessons/{lesson_id}/audit`
                .replace(`{${"lesson_id"}}`, encodeURIComponent(String(lessonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuditApi - functional programming interface
 * @export
 */
export const AuditApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuditApiAxiosParamCreator(configuration)
    return {
        /**
         * Journal d\'audit pour un cours. Rôle: DIRECTION
         * @summary Get Lesson Audit
         * @param {string} lessonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLessonAuditLessonsLessonIdAuditGet(lessonId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TimetableAuditRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLessonAuditLessonsLessonIdAuditGet(lessonId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuditApi.getLessonAuditLessonsLessonIdAuditGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuditApi - factory interface
 * @export
 */
export const AuditApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuditApiFp(configuration)
    return {
        /**
         * Journal d\'audit pour un cours. Rôle: DIRECTION
         * @summary Get Lesson Audit
         * @param {string} lessonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLessonAuditLessonsLessonIdAuditGet(lessonId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TimetableAuditRead>> {
            return localVarFp.getLessonAuditLessonsLessonIdAuditGet(lessonId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuditApi - object-oriented interface
 * @export
 * @class AuditApi
 * @extends {BaseAPI}
 */
export class AuditApi extends BaseAPI {
    /**
     * Journal d\'audit pour un cours. Rôle: DIRECTION
     * @summary Get Lesson Audit
     * @param {string} lessonId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditApi
     */
    public getLessonAuditLessonsLessonIdAuditGet(lessonId: string, options?: RawAxiosRequestConfig) {
        return AuditApiFp(this.configuration).getLessonAuditLessonsLessonIdAuditGet(lessonId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FeedApi - axios parameter creator
 * @export
 */
export const FeedApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Flux iCalendar pour une classe.
         * @summary Get Ics Feed
         * @param {string} classId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIcsFeedFeedClassIdIcsGet: async (classId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('getIcsFeedFeedClassIdIcsGet', 'classId', classId)
            const localVarPath = `/feed/{class_id}.ics`
                .replace(`{${"class_id"}}`, encodeURIComponent(String(classId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeedApi - functional programming interface
 * @export
 */
export const FeedApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FeedApiAxiosParamCreator(configuration)
    return {
        /**
         * Flux iCalendar pour une classe.
         * @summary Get Ics Feed
         * @param {string} classId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIcsFeedFeedClassIdIcsGet(classId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIcsFeedFeedClassIdIcsGet(classId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeedApi.getIcsFeedFeedClassIdIcsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FeedApi - factory interface
 * @export
 */
export const FeedApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FeedApiFp(configuration)
    return {
        /**
         * Flux iCalendar pour une classe.
         * @summary Get Ics Feed
         * @param {string} classId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIcsFeedFeedClassIdIcsGet(classId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getIcsFeedFeedClassIdIcsGet(classId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FeedApi - object-oriented interface
 * @export
 * @class FeedApi
 * @extends {BaseAPI}
 */
export class FeedApi extends BaseAPI {
    /**
     * Flux iCalendar pour une classe.
     * @summary Get Ics Feed
     * @param {string} classId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedApi
     */
    public getIcsFeedFeedClassIdIcsGet(classId: string, options?: RawAxiosRequestConfig) {
        return FeedApiFp(this.configuration).getIcsFeedFeedClassIdIcsGet(classId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthHealthGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthHealthGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthHealthGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.healthHealthGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * 
         * @summary Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthHealthGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.healthHealthGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * 
     * @summary Health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public healthHealthGet(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).healthHealthGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LessonsApi - axios parameter creator
 * @export
 */
export const LessonsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Créer un cours ou une série (repeatweekly). Rôles: ENSEIGNANT, COORDONNATEUR, ADMIN
         * @summary Create Lessons
         * @param {LessonCreate} lessonCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLessonsLessonsPost: async (lessonCreate: LessonCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lessonCreate' is not null or undefined
            assertParamExists('createLessonsLessonsPost', 'lessonCreate', lessonCreate)
            const localVarPath = `/lessons/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lessonCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Supprimer un cours. Rôles: COORDONNATEUR, ADMIN
         * @summary Delete Lesson
         * @param {string} lessonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLessonLessonsLessonIdDelete: async (lessonId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lessonId' is not null or undefined
            assertParamExists('deleteLessonLessonsLessonIdDelete', 'lessonId', lessonId)
            const localVarPath = `/lessons/{lesson_id}`
                .replace(`{${"lesson_id"}}`, encodeURIComponent(String(lessonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lister les cours (filtres: classe, prof, dates). Rôles: tous. PARENT: accès restreint.
         * @summary List Lessons
         * @param {string | null} [classId] 
         * @param {string | null} [fromDate] 
         * @param {string | null} [toDate] 
         * @param {string | null} [teacherId] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLessonsLessonsGet: async (classId?: string | null, fromDate?: string | null, toDate?: string | null, teacherId?: string | null, skip?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lessons/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (classId !== undefined) {
                localVarQueryParameter['class_id'] = classId;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from_date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString().substring(0,10) :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to_date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString().substring(0,10) :
                    toDate;
            }

            if (teacherId !== undefined) {
                localVarQueryParameter['teacher_id'] = teacherId;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mettre à jour salle/timeslot. Vérifie conflit. Rôles: ENSEIGNANT, COORDONNATEUR, ADMIN
         * @summary Update Lesson
         * @param {string} lessonId 
         * @param {LessonUpdate} lessonUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLessonLessonsLessonIdPatch: async (lessonId: string, lessonUpdate: LessonUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lessonId' is not null or undefined
            assertParamExists('updateLessonLessonsLessonIdPatch', 'lessonId', lessonId)
            // verify required parameter 'lessonUpdate' is not null or undefined
            assertParamExists('updateLessonLessonsLessonIdPatch', 'lessonUpdate', lessonUpdate)
            const localVarPath = `/lessons/{lesson_id}`
                .replace(`{${"lesson_id"}}`, encodeURIComponent(String(lessonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lessonUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LessonsApi - functional programming interface
 * @export
 */
export const LessonsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LessonsApiAxiosParamCreator(configuration)
    return {
        /**
         * Créer un cours ou une série (repeatweekly). Rôles: ENSEIGNANT, COORDONNATEUR, ADMIN
         * @summary Create Lessons
         * @param {LessonCreate} lessonCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLessonsLessonsPost(lessonCreate: LessonCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LessonRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLessonsLessonsPost(lessonCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LessonsApi.createLessonsLessonsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Supprimer un cours. Rôles: COORDONNATEUR, ADMIN
         * @summary Delete Lesson
         * @param {string} lessonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLessonLessonsLessonIdDelete(lessonId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LessonRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLessonLessonsLessonIdDelete(lessonId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LessonsApi.deleteLessonLessonsLessonIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lister les cours (filtres: classe, prof, dates). Rôles: tous. PARENT: accès restreint.
         * @summary List Lessons
         * @param {string | null} [classId] 
         * @param {string | null} [fromDate] 
         * @param {string | null} [toDate] 
         * @param {string | null} [teacherId] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLessonsLessonsGet(classId?: string | null, fromDate?: string | null, toDate?: string | null, teacherId?: string | null, skip?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LessonRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLessonsLessonsGet(classId, fromDate, toDate, teacherId, skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LessonsApi.listLessonsLessonsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Mettre à jour salle/timeslot. Vérifie conflit. Rôles: ENSEIGNANT, COORDONNATEUR, ADMIN
         * @summary Update Lesson
         * @param {string} lessonId 
         * @param {LessonUpdate} lessonUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLessonLessonsLessonIdPatch(lessonId: string, lessonUpdate: LessonUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LessonRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLessonLessonsLessonIdPatch(lessonId, lessonUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LessonsApi.updateLessonLessonsLessonIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LessonsApi - factory interface
 * @export
 */
export const LessonsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LessonsApiFp(configuration)
    return {
        /**
         * Créer un cours ou une série (repeatweekly). Rôles: ENSEIGNANT, COORDONNATEUR, ADMIN
         * @summary Create Lessons
         * @param {LessonCreate} lessonCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLessonsLessonsPost(lessonCreate: LessonCreate, options?: RawAxiosRequestConfig): AxiosPromise<LessonRead> {
            return localVarFp.createLessonsLessonsPost(lessonCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Supprimer un cours. Rôles: COORDONNATEUR, ADMIN
         * @summary Delete Lesson
         * @param {string} lessonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLessonLessonsLessonIdDelete(lessonId: string, options?: RawAxiosRequestConfig): AxiosPromise<LessonRead> {
            return localVarFp.deleteLessonLessonsLessonIdDelete(lessonId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lister les cours (filtres: classe, prof, dates). Rôles: tous. PARENT: accès restreint.
         * @summary List Lessons
         * @param {string | null} [classId] 
         * @param {string | null} [fromDate] 
         * @param {string | null} [toDate] 
         * @param {string | null} [teacherId] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLessonsLessonsGet(classId?: string | null, fromDate?: string | null, toDate?: string | null, teacherId?: string | null, skip?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<LessonRead>> {
            return localVarFp.listLessonsLessonsGet(classId, fromDate, toDate, teacherId, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Mettre à jour salle/timeslot. Vérifie conflit. Rôles: ENSEIGNANT, COORDONNATEUR, ADMIN
         * @summary Update Lesson
         * @param {string} lessonId 
         * @param {LessonUpdate} lessonUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLessonLessonsLessonIdPatch(lessonId: string, lessonUpdate: LessonUpdate, options?: RawAxiosRequestConfig): AxiosPromise<LessonRead> {
            return localVarFp.updateLessonLessonsLessonIdPatch(lessonId, lessonUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LessonsApi - object-oriented interface
 * @export
 * @class LessonsApi
 * @extends {BaseAPI}
 */
export class LessonsApi extends BaseAPI {
    /**
     * Créer un cours ou une série (repeatweekly). Rôles: ENSEIGNANT, COORDONNATEUR, ADMIN
     * @summary Create Lessons
     * @param {LessonCreate} lessonCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonsApi
     */
    public createLessonsLessonsPost(lessonCreate: LessonCreate, options?: RawAxiosRequestConfig) {
        return LessonsApiFp(this.configuration).createLessonsLessonsPost(lessonCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Supprimer un cours. Rôles: COORDONNATEUR, ADMIN
     * @summary Delete Lesson
     * @param {string} lessonId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonsApi
     */
    public deleteLessonLessonsLessonIdDelete(lessonId: string, options?: RawAxiosRequestConfig) {
        return LessonsApiFp(this.configuration).deleteLessonLessonsLessonIdDelete(lessonId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lister les cours (filtres: classe, prof, dates). Rôles: tous. PARENT: accès restreint.
     * @summary List Lessons
     * @param {string | null} [classId] 
     * @param {string | null} [fromDate] 
     * @param {string | null} [toDate] 
     * @param {string | null} [teacherId] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonsApi
     */
    public listLessonsLessonsGet(classId?: string | null, fromDate?: string | null, toDate?: string | null, teacherId?: string | null, skip?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return LessonsApiFp(this.configuration).listLessonsLessonsGet(classId, fromDate, toDate, teacherId, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mettre à jour salle/timeslot. Vérifie conflit. Rôles: ENSEIGNANT, COORDONNATEUR, ADMIN
     * @summary Update Lesson
     * @param {string} lessonId 
     * @param {LessonUpdate} lessonUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonsApi
     */
    public updateLessonLessonsLessonIdPatch(lessonId: string, lessonUpdate: LessonUpdate, options?: RawAxiosRequestConfig) {
        return LessonsApiFp(this.configuration).updateLessonLessonsLessonIdPatch(lessonId, lessonUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReplacementsApi - axios parameter creator
 * @export
 */
export const ReplacementsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Créer un remplacement (status=REPLACED). Rôles: COORDONNATEUR, DIRECTION, ADMIN
         * @summary Create Replacement
         * @param {ReplacementCreate} replacementCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReplacementReplacementsPost: async (replacementCreate: ReplacementCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'replacementCreate' is not null or undefined
            assertParamExists('createReplacementReplacementsPost', 'replacementCreate', replacementCreate)
            const localVarPath = `/replacements/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(replacementCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Supprimer un remplacement. Rôles: COORDONNATEUR, ADMIN
         * @summary Delete Replacement
         * @param {string} replacementId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReplacementReplacementsReplacementIdDelete: async (replacementId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'replacementId' is not null or undefined
            assertParamExists('deleteReplacementReplacementsReplacementIdDelete', 'replacementId', replacementId)
            const localVarPath = `/replacements/{replacement_id}`
                .replace(`{${"replacement_id"}}`, encodeURIComponent(String(replacementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReplacementsApi - functional programming interface
 * @export
 */
export const ReplacementsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReplacementsApiAxiosParamCreator(configuration)
    return {
        /**
         * Créer un remplacement (status=REPLACED). Rôles: COORDONNATEUR, DIRECTION, ADMIN
         * @summary Create Replacement
         * @param {ReplacementCreate} replacementCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReplacementReplacementsPost(replacementCreate: ReplacementCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReplacementRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createReplacementReplacementsPost(replacementCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReplacementsApi.createReplacementReplacementsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Supprimer un remplacement. Rôles: COORDONNATEUR, ADMIN
         * @summary Delete Replacement
         * @param {string} replacementId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteReplacementReplacementsReplacementIdDelete(replacementId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReplacementRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteReplacementReplacementsReplacementIdDelete(replacementId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReplacementsApi.deleteReplacementReplacementsReplacementIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReplacementsApi - factory interface
 * @export
 */
export const ReplacementsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReplacementsApiFp(configuration)
    return {
        /**
         * Créer un remplacement (status=REPLACED). Rôles: COORDONNATEUR, DIRECTION, ADMIN
         * @summary Create Replacement
         * @param {ReplacementCreate} replacementCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReplacementReplacementsPost(replacementCreate: ReplacementCreate, options?: RawAxiosRequestConfig): AxiosPromise<ReplacementRead> {
            return localVarFp.createReplacementReplacementsPost(replacementCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Supprimer un remplacement. Rôles: COORDONNATEUR, ADMIN
         * @summary Delete Replacement
         * @param {string} replacementId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReplacementReplacementsReplacementIdDelete(replacementId: string, options?: RawAxiosRequestConfig): AxiosPromise<ReplacementRead> {
            return localVarFp.deleteReplacementReplacementsReplacementIdDelete(replacementId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReplacementsApi - object-oriented interface
 * @export
 * @class ReplacementsApi
 * @extends {BaseAPI}
 */
export class ReplacementsApi extends BaseAPI {
    /**
     * Créer un remplacement (status=REPLACED). Rôles: COORDONNATEUR, DIRECTION, ADMIN
     * @summary Create Replacement
     * @param {ReplacementCreate} replacementCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReplacementsApi
     */
    public createReplacementReplacementsPost(replacementCreate: ReplacementCreate, options?: RawAxiosRequestConfig) {
        return ReplacementsApiFp(this.configuration).createReplacementReplacementsPost(replacementCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Supprimer un remplacement. Rôles: COORDONNATEUR, ADMIN
     * @summary Delete Replacement
     * @param {string} replacementId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReplacementsApi
     */
    public deleteReplacementReplacementsReplacementIdDelete(replacementId: string, options?: RawAxiosRequestConfig) {
        return ReplacementsApiFp(this.configuration).deleteReplacementReplacementsReplacementIdDelete(replacementId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RoomsApi - axios parameter creator
 * @export
 */
export const RoomsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Créer une salle. Rôles: ADMIN, COORDONNATEUR
         * @summary Create Room
         * @param {RoomCreate} roomCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoomRoomsPost: async (roomCreate: RoomCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomCreate' is not null or undefined
            assertParamExists('createRoomRoomsPost', 'roomCreate', roomCreate)
            const localVarPath = `/rooms/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roomCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lister les salles.
         * @summary List Rooms
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoomsRoomsGet: async (skip?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rooms/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoomsApi - functional programming interface
 * @export
 */
export const RoomsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoomsApiAxiosParamCreator(configuration)
    return {
        /**
         * Créer une salle. Rôles: ADMIN, COORDONNATEUR
         * @summary Create Room
         * @param {RoomCreate} roomCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRoomRoomsPost(roomCreate: RoomCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRoomRoomsPost(roomCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.createRoomRoomsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lister les salles.
         * @summary List Rooms
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRoomsRoomsGet(skip?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoomRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRoomsRoomsGet(skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.listRoomsRoomsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RoomsApi - factory interface
 * @export
 */
export const RoomsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoomsApiFp(configuration)
    return {
        /**
         * Créer une salle. Rôles: ADMIN, COORDONNATEUR
         * @summary Create Room
         * @param {RoomCreate} roomCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoomRoomsPost(roomCreate: RoomCreate, options?: RawAxiosRequestConfig): AxiosPromise<RoomRead> {
            return localVarFp.createRoomRoomsPost(roomCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Lister les salles.
         * @summary List Rooms
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoomsRoomsGet(skip?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<RoomRead>> {
            return localVarFp.listRoomsRoomsGet(skip, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoomsApi - object-oriented interface
 * @export
 * @class RoomsApi
 * @extends {BaseAPI}
 */
export class RoomsApi extends BaseAPI {
    /**
     * Créer une salle. Rôles: ADMIN, COORDONNATEUR
     * @summary Create Room
     * @param {RoomCreate} roomCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public createRoomRoomsPost(roomCreate: RoomCreate, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).createRoomRoomsPost(roomCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lister les salles.
     * @summary List Rooms
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public listRoomsRoomsGet(skip?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).listRoomsRoomsGet(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TimeslotsApi - axios parameter creator
 * @export
 */
export const TimeslotsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Créer un créneau horaire. Rôles: ADMIN, COORDONNATEUR
         * @summary Create Timeslot
         * @param {TimeslotCreate} timeslotCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTimeslotTimeslotsPost: async (timeslotCreate: TimeslotCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timeslotCreate' is not null or undefined
            assertParamExists('createTimeslotTimeslotsPost', 'timeslotCreate', timeslotCreate)
            const localVarPath = `/timeslots/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(timeslotCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lister les créneaux horaires.
         * @summary List Timeslots
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTimeslotsTimeslotsGet: async (skip?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/timeslots/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimeslotsApi - functional programming interface
 * @export
 */
export const TimeslotsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TimeslotsApiAxiosParamCreator(configuration)
    return {
        /**
         * Créer un créneau horaire. Rôles: ADMIN, COORDONNATEUR
         * @summary Create Timeslot
         * @param {TimeslotCreate} timeslotCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTimeslotTimeslotsPost(timeslotCreate: TimeslotCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimeslotRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTimeslotTimeslotsPost(timeslotCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TimeslotsApi.createTimeslotTimeslotsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lister les créneaux horaires.
         * @summary List Timeslots
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTimeslotsTimeslotsGet(skip?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TimeslotRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTimeslotsTimeslotsGet(skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TimeslotsApi.listTimeslotsTimeslotsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TimeslotsApi - factory interface
 * @export
 */
export const TimeslotsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TimeslotsApiFp(configuration)
    return {
        /**
         * Créer un créneau horaire. Rôles: ADMIN, COORDONNATEUR
         * @summary Create Timeslot
         * @param {TimeslotCreate} timeslotCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTimeslotTimeslotsPost(timeslotCreate: TimeslotCreate, options?: RawAxiosRequestConfig): AxiosPromise<TimeslotRead> {
            return localVarFp.createTimeslotTimeslotsPost(timeslotCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Lister les créneaux horaires.
         * @summary List Timeslots
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTimeslotsTimeslotsGet(skip?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<TimeslotRead>> {
            return localVarFp.listTimeslotsTimeslotsGet(skip, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TimeslotsApi - object-oriented interface
 * @export
 * @class TimeslotsApi
 * @extends {BaseAPI}
 */
export class TimeslotsApi extends BaseAPI {
    /**
     * Créer un créneau horaire. Rôles: ADMIN, COORDONNATEUR
     * @summary Create Timeslot
     * @param {TimeslotCreate} timeslotCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeslotsApi
     */
    public createTimeslotTimeslotsPost(timeslotCreate: TimeslotCreate, options?: RawAxiosRequestConfig) {
        return TimeslotsApiFp(this.configuration).createTimeslotTimeslotsPost(timeslotCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lister les créneaux horaires.
     * @summary List Timeslots
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeslotsApi
     */
    public listTimeslotsTimeslotsGet(skip?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return TimeslotsApiFp(this.configuration).listTimeslotsTimeslotsGet(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



