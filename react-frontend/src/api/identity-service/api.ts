/* tslint:disable */
/* eslint-disable */
/**
 * identity-service
 * Service de gestion des identités - Bulk Import et Traçabilité
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Schéma pour lire un batch d\'identités.
 * @export
 * @interface BatchRead
 */
export interface BatchRead {
    /**
     * ID du batch
     * @type {string}
     * @memberof BatchRead
     */
    'id': string;
    /**
     * ID de l\'établissement
     * @type {string}
     * @memberof BatchRead
     */
    'establishment_id': string;
    /**
     * ID de l\'uploader
     * @type {string}
     * @memberof BatchRead
     */
    'uploaded_by': string;
    /**
     * URL du fichier source
     * @type {string}
     * @memberof BatchRead
     */
    'source_file_url': string;
    /**
     * Date de création
     * @type {string}
     * @memberof BatchRead
     */
    'created_at': string;
}
/**
 * Schéma pour la réponse de bulk import.
 * @export
 * @interface BulkImportResponse
 */
export interface BulkImportResponse {
    /**
     * ID du batch créé
     * @type {string}
     * @memberof BulkImportResponse
     */
    'batch_id': string;
    /**
     * Statut de l\'import
     * @type {string}
     * @memberof BulkImportResponse
     */
    'status': string;
    /**
     * Message d\'information
     * @type {string}
     * @memberof BulkImportResponse
     */
    'message': string;
    /**
     * Nombre total d\'éléments traités
     * @type {number}
     * @memberof BulkImportResponse
     */
    'total_items': number;
    /**
     * Nombre d\'éléments créés
     * @type {number}
     * @memberof BulkImportResponse
     */
    'new_count': number;
    /**
     * Nombre d\'éléments mis à jour
     * @type {number}
     * @memberof BulkImportResponse
     */
    'updated_count': number;
    /**
     * Nombre d\'éléments ignorés
     * @type {number}
     * @memberof BulkImportResponse
     */
    'skipped_count': number;
    /**
     * Nombre d\'éléments invalides
     * @type {number}
     * @memberof BulkImportResponse
     */
    'invalid_count': number;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<ValidationErrorLocInner>}
     * @memberof ValidationError
     */
    'loc': Array<ValidationErrorLocInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {
}

/**
 * BatchesApi - axios parameter creator
 * @export
 */
export const BatchesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Marquer un batch comme COMMITTED (optionnel).  Args:     batch_id: ID du batch     identity_service: Service d\'identité     current_user: Utilisateur authentifié  Returns:     dict: Message de confirmation  Raises:     404: Batch non trouvé     400: Erreur lors du commit
         * @summary Commit Batch
         * @param {string} batchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitBatchApiV1IdentityBatchesBatchIdCommitPost: async (batchId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('commitBatchApiV1IdentityBatchesBatchIdCommitPost', 'batchId', batchId)
            const localVarPath = `/api/v1/identity/batches/{batch_id}/commit`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupérer un batch par son ID.  Args:     batch_id: ID du batch     batch_service: Service de gestion des batches     current_user: Utilisateur authentifié  Returns:     BatchRead: Détails du batch  Raises:     404: Batch non trouvé
         * @summary Get Batch
         * @param {string} batchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchApiV1IdentityBatchesBatchIdGet: async (batchId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('getBatchApiV1IdentityBatchesBatchIdGet', 'batchId', batchId)
            const localVarPath = `/api/v1/identity/batches/{batch_id}`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lister les items d\'un batch avec pagination et filtres.  Args:     batch_id: ID du batch     item_status: Statut des items pour filtrer (NEW, UPDATED, SKIPPED, INVALID)     domain: Domaine des items pour filtrer (student, parent, teacher, admin_staff)     pagination: Paramètres de pagination et tri     identity_service: Service d\'identité     current_user: Utilisateur authentifié  Returns:     dict: Liste paginée des items du batch  Raises:     404: Batch non trouvé
         * @summary Get Batch Items
         * @param {string} batchId 
         * @param {string | null} [itemStatus] 
         * @param {string | null} [domain] 
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de page
         * @param {string | null} [orderBy] Colonne de tri
         * @param {string} [orderDir] Sens de tri (asc/desc)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchItemsApiV1IdentityBatchesBatchIdItemsGet: async (batchId: string, itemStatus?: string | null, domain?: string | null, page?: number, size?: number, orderBy?: string | null, orderDir?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('getBatchItemsApiV1IdentityBatchesBatchIdItemsGet', 'batchId', batchId)
            const localVarPath = `/api/v1/identity/batches/{batch_id}/items`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (itemStatus !== undefined) {
                localVarQueryParameter['item_status'] = itemStatus;
            }

            if (domain !== undefined) {
                localVarQueryParameter['domain'] = domain;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderDir !== undefined) {
                localVarQueryParameter['order_dir'] = orderDir;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lister les batches d\'identités avec pagination et filtres.  Args:     establishment_id: ID de l\'établissement pour filtrer     uploaded_by: ID de l\'uploader pour filtrer     pagination: Paramètres de pagination et tri     batch_service: Service de gestion des batches     current_user: Utilisateur authentifié  Returns:     dict: Liste paginée des batches
         * @summary List Batches
         * @param {string | null} [establishmentId] 
         * @param {string | null} [uploadedBy] 
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de page
         * @param {string | null} [orderBy] Colonne de tri
         * @param {string} [orderDir] Sens de tri (asc/desc)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchesApiV1IdentityBatchesGet: async (establishmentId?: string | null, uploadedBy?: string | null, page?: number, size?: number, orderBy?: string | null, orderDir?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/identity/batches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (establishmentId !== undefined) {
                localVarQueryParameter['establishment_id'] = establishmentId;
            }

            if (uploadedBy !== undefined) {
                localVarQueryParameter['uploaded_by'] = uploadedBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderDir !== undefined) {
                localVarQueryParameter['order_dir'] = orderDir;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BatchesApi - functional programming interface
 * @export
 */
export const BatchesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BatchesApiAxiosParamCreator(configuration)
    return {
        /**
         * Marquer un batch comme COMMITTED (optionnel).  Args:     batch_id: ID du batch     identity_service: Service d\'identité     current_user: Utilisateur authentifié  Returns:     dict: Message de confirmation  Raises:     404: Batch non trouvé     400: Erreur lors du commit
         * @summary Commit Batch
         * @param {string} batchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commitBatchApiV1IdentityBatchesBatchIdCommitPost(batchId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commitBatchApiV1IdentityBatchesBatchIdCommitPost(batchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchesApi.commitBatchApiV1IdentityBatchesBatchIdCommitPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Récupérer un batch par son ID.  Args:     batch_id: ID du batch     batch_service: Service de gestion des batches     current_user: Utilisateur authentifié  Returns:     BatchRead: Détails du batch  Raises:     404: Batch non trouvé
         * @summary Get Batch
         * @param {string} batchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBatchApiV1IdentityBatchesBatchIdGet(batchId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBatchApiV1IdentityBatchesBatchIdGet(batchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchesApi.getBatchApiV1IdentityBatchesBatchIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lister les items d\'un batch avec pagination et filtres.  Args:     batch_id: ID du batch     item_status: Statut des items pour filtrer (NEW, UPDATED, SKIPPED, INVALID)     domain: Domaine des items pour filtrer (student, parent, teacher, admin_staff)     pagination: Paramètres de pagination et tri     identity_service: Service d\'identité     current_user: Utilisateur authentifié  Returns:     dict: Liste paginée des items du batch  Raises:     404: Batch non trouvé
         * @summary Get Batch Items
         * @param {string} batchId 
         * @param {string | null} [itemStatus] 
         * @param {string | null} [domain] 
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de page
         * @param {string | null} [orderBy] Colonne de tri
         * @param {string} [orderDir] Sens de tri (asc/desc)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBatchItemsApiV1IdentityBatchesBatchIdItemsGet(batchId: string, itemStatus?: string | null, domain?: string | null, page?: number, size?: number, orderBy?: string | null, orderDir?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBatchItemsApiV1IdentityBatchesBatchIdItemsGet(batchId, itemStatus, domain, page, size, orderBy, orderDir, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchesApi.getBatchItemsApiV1IdentityBatchesBatchIdItemsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lister les batches d\'identités avec pagination et filtres.  Args:     establishment_id: ID de l\'établissement pour filtrer     uploaded_by: ID de l\'uploader pour filtrer     pagination: Paramètres de pagination et tri     batch_service: Service de gestion des batches     current_user: Utilisateur authentifié  Returns:     dict: Liste paginée des batches
         * @summary List Batches
         * @param {string | null} [establishmentId] 
         * @param {string | null} [uploadedBy] 
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de page
         * @param {string | null} [orderBy] Colonne de tri
         * @param {string} [orderDir] Sens de tri (asc/desc)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBatchesApiV1IdentityBatchesGet(establishmentId?: string | null, uploadedBy?: string | null, page?: number, size?: number, orderBy?: string | null, orderDir?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBatchesApiV1IdentityBatchesGet(establishmentId, uploadedBy, page, size, orderBy, orderDir, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchesApi.listBatchesApiV1IdentityBatchesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BatchesApi - factory interface
 * @export
 */
export const BatchesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BatchesApiFp(configuration)
    return {
        /**
         * Marquer un batch comme COMMITTED (optionnel).  Args:     batch_id: ID du batch     identity_service: Service d\'identité     current_user: Utilisateur authentifié  Returns:     dict: Message de confirmation  Raises:     404: Batch non trouvé     400: Erreur lors du commit
         * @summary Commit Batch
         * @param {string} batchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitBatchApiV1IdentityBatchesBatchIdCommitPost(batchId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.commitBatchApiV1IdentityBatchesBatchIdCommitPost(batchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupérer un batch par son ID.  Args:     batch_id: ID du batch     batch_service: Service de gestion des batches     current_user: Utilisateur authentifié  Returns:     BatchRead: Détails du batch  Raises:     404: Batch non trouvé
         * @summary Get Batch
         * @param {string} batchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchApiV1IdentityBatchesBatchIdGet(batchId: string, options?: RawAxiosRequestConfig): AxiosPromise<BatchRead> {
            return localVarFp.getBatchApiV1IdentityBatchesBatchIdGet(batchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lister les items d\'un batch avec pagination et filtres.  Args:     batch_id: ID du batch     item_status: Statut des items pour filtrer (NEW, UPDATED, SKIPPED, INVALID)     domain: Domaine des items pour filtrer (student, parent, teacher, admin_staff)     pagination: Paramètres de pagination et tri     identity_service: Service d\'identité     current_user: Utilisateur authentifié  Returns:     dict: Liste paginée des items du batch  Raises:     404: Batch non trouvé
         * @summary Get Batch Items
         * @param {string} batchId 
         * @param {string | null} [itemStatus] 
         * @param {string | null} [domain] 
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de page
         * @param {string | null} [orderBy] Colonne de tri
         * @param {string} [orderDir] Sens de tri (asc/desc)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchItemsApiV1IdentityBatchesBatchIdItemsGet(batchId: string, itemStatus?: string | null, domain?: string | null, page?: number, size?: number, orderBy?: string | null, orderDir?: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getBatchItemsApiV1IdentityBatchesBatchIdItemsGet(batchId, itemStatus, domain, page, size, orderBy, orderDir, options).then((request) => request(axios, basePath));
        },
        /**
         * Lister les batches d\'identités avec pagination et filtres.  Args:     establishment_id: ID de l\'établissement pour filtrer     uploaded_by: ID de l\'uploader pour filtrer     pagination: Paramètres de pagination et tri     batch_service: Service de gestion des batches     current_user: Utilisateur authentifié  Returns:     dict: Liste paginée des batches
         * @summary List Batches
         * @param {string | null} [establishmentId] 
         * @param {string | null} [uploadedBy] 
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de page
         * @param {string | null} [orderBy] Colonne de tri
         * @param {string} [orderDir] Sens de tri (asc/desc)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchesApiV1IdentityBatchesGet(establishmentId?: string | null, uploadedBy?: string | null, page?: number, size?: number, orderBy?: string | null, orderDir?: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.listBatchesApiV1IdentityBatchesGet(establishmentId, uploadedBy, page, size, orderBy, orderDir, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BatchesApi - object-oriented interface
 * @export
 * @class BatchesApi
 * @extends {BaseAPI}
 */
export class BatchesApi extends BaseAPI {
    /**
     * Marquer un batch comme COMMITTED (optionnel).  Args:     batch_id: ID du batch     identity_service: Service d\'identité     current_user: Utilisateur authentifié  Returns:     dict: Message de confirmation  Raises:     404: Batch non trouvé     400: Erreur lors du commit
     * @summary Commit Batch
     * @param {string} batchId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public commitBatchApiV1IdentityBatchesBatchIdCommitPost(batchId: string, options?: RawAxiosRequestConfig) {
        return BatchesApiFp(this.configuration).commitBatchApiV1IdentityBatchesBatchIdCommitPost(batchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupérer un batch par son ID.  Args:     batch_id: ID du batch     batch_service: Service de gestion des batches     current_user: Utilisateur authentifié  Returns:     BatchRead: Détails du batch  Raises:     404: Batch non trouvé
     * @summary Get Batch
     * @param {string} batchId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public getBatchApiV1IdentityBatchesBatchIdGet(batchId: string, options?: RawAxiosRequestConfig) {
        return BatchesApiFp(this.configuration).getBatchApiV1IdentityBatchesBatchIdGet(batchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lister les items d\'un batch avec pagination et filtres.  Args:     batch_id: ID du batch     item_status: Statut des items pour filtrer (NEW, UPDATED, SKIPPED, INVALID)     domain: Domaine des items pour filtrer (student, parent, teacher, admin_staff)     pagination: Paramètres de pagination et tri     identity_service: Service d\'identité     current_user: Utilisateur authentifié  Returns:     dict: Liste paginée des items du batch  Raises:     404: Batch non trouvé
     * @summary Get Batch Items
     * @param {string} batchId 
     * @param {string | null} [itemStatus] 
     * @param {string | null} [domain] 
     * @param {number} [page] Numéro de page
     * @param {number} [size] Taille de page
     * @param {string | null} [orderBy] Colonne de tri
     * @param {string} [orderDir] Sens de tri (asc/desc)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public getBatchItemsApiV1IdentityBatchesBatchIdItemsGet(batchId: string, itemStatus?: string | null, domain?: string | null, page?: number, size?: number, orderBy?: string | null, orderDir?: string, options?: RawAxiosRequestConfig) {
        return BatchesApiFp(this.configuration).getBatchItemsApiV1IdentityBatchesBatchIdItemsGet(batchId, itemStatus, domain, page, size, orderBy, orderDir, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lister les batches d\'identités avec pagination et filtres.  Args:     establishment_id: ID de l\'établissement pour filtrer     uploaded_by: ID de l\'uploader pour filtrer     pagination: Paramètres de pagination et tri     batch_service: Service de gestion des batches     current_user: Utilisateur authentifié  Returns:     dict: Liste paginée des batches
     * @summary List Batches
     * @param {string | null} [establishmentId] 
     * @param {string | null} [uploadedBy] 
     * @param {number} [page] Numéro de page
     * @param {number} [size] Taille de page
     * @param {string | null} [orderBy] Colonne de tri
     * @param {string} [orderDir] Sens de tri (asc/desc)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public listBatchesApiV1IdentityBatchesGet(establishmentId?: string | null, uploadedBy?: string | null, page?: number, size?: number, orderBy?: string | null, orderDir?: string, options?: RawAxiosRequestConfig) {
        return BatchesApiFp(this.configuration).listBatchesApiV1IdentityBatchesGet(establishmentId, uploadedBy, page, size, orderBy, orderDir, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Import en masse d\'identités via fichier CSV.       Accepte les formats CSV avec les schémas suivants :  - **students.csv** : establishment_id;firstname;lastname;birth_date;gender;level;account_required;email;phone  - **parents.csv** : establishment_id;firstname;lastname;email;phone  - **teachers.csv** : establishment_id;firstname;lastname;email;phone;subject;hire_date  - **admin_staff.csv** : establishment_id;firstname;lastname;email;phone;position;hire_date    Note: L\'external_id (ID Keycloak) sera automatiquement généré lors de la création du compte.    Le domaine est automatiquement détecté à partir des en-têtes du CSV.
         * @summary Bulk Import Identities
         * @param {File} file Fichier CSV à importer
         * @param {string} establishmentId ID de l\\\&#39;établissement
         * @param {string | null} [sourceFileUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkImportIdentitiesApiV1IdentityBulkimportPost: async (file: File, establishmentId: string, sourceFileUrl?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('bulkImportIdentitiesApiV1IdentityBulkimportPost', 'file', file)
            // verify required parameter 'establishmentId' is not null or undefined
            assertParamExists('bulkImportIdentitiesApiV1IdentityBulkimportPost', 'establishmentId', establishmentId)
            const localVarPath = `/api/v1/identity/bulkimport`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (establishmentId !== undefined) { 
                localVarFormParams.append('establishment_id', establishmentId as any);
            }
    
            if (sourceFileUrl !== undefined) { 
                localVarFormParams.append('source_file_url', sourceFileUrl as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère l\'historique d\'audit des opérations de bulk import.  Args:     user_id: Filtrer par utilisateur     establishment_id: Filtrer par établissement     batch_id: Filtrer par batch     limit: Limite du nombre de résultats
         * @summary Get Audit History
         * @param {string | null} [userId] 
         * @param {string | null} [establishmentId] 
         * @param {string | null} [batchId] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditHistoryApiV1IdentityBulkimportAuditGet: async (userId?: string | null, establishmentId?: string | null, batchId?: string | null, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/identity/bulkimport/audit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (establishmentId !== undefined) {
                localVarQueryParameter['establishment_id'] = establishmentId;
            }

            if (batchId !== undefined) {
                localVarQueryParameter['batch_id'] = batchId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère un template CSV pour un domaine donné.  Args:     domain: Domaine (student, parent, teacher, admin_staff)
         * @summary Get Csv Template
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCsvTemplateApiV1IdentityBulkimportTemplateDomainGet: async (domain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('getCsvTemplateApiV1IdentityBulkimportTemplateDomainGet', 'domain', domain)
            const localVarPath = `/api/v1/identity/bulkimport/template/{domain}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint de vérification de santé du service.
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheckHealthGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint racine pour vérifier que le service fonctionne.
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Import en masse d\'identités via fichier CSV.       Accepte les formats CSV avec les schémas suivants :  - **students.csv** : establishment_id;firstname;lastname;birth_date;gender;level;account_required;email;phone  - **parents.csv** : establishment_id;firstname;lastname;email;phone  - **teachers.csv** : establishment_id;firstname;lastname;email;phone;subject;hire_date  - **admin_staff.csv** : establishment_id;firstname;lastname;email;phone;position;hire_date    Note: L\'external_id (ID Keycloak) sera automatiquement généré lors de la création du compte.    Le domaine est automatiquement détecté à partir des en-têtes du CSV.
         * @summary Bulk Import Identities
         * @param {File} file Fichier CSV à importer
         * @param {string} establishmentId ID de l\\\&#39;établissement
         * @param {string | null} [sourceFileUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkImportIdentitiesApiV1IdentityBulkimportPost(file: File, establishmentId: string, sourceFileUrl?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkImportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkImportIdentitiesApiV1IdentityBulkimportPost(file, establishmentId, sourceFileUrl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.bulkImportIdentitiesApiV1IdentityBulkimportPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Récupère l\'historique d\'audit des opérations de bulk import.  Args:     user_id: Filtrer par utilisateur     establishment_id: Filtrer par établissement     batch_id: Filtrer par batch     limit: Limite du nombre de résultats
         * @summary Get Audit History
         * @param {string | null} [userId] 
         * @param {string | null} [establishmentId] 
         * @param {string | null} [batchId] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuditHistoryApiV1IdentityBulkimportAuditGet(userId?: string | null, establishmentId?: string | null, batchId?: string | null, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuditHistoryApiV1IdentityBulkimportAuditGet(userId, establishmentId, batchId, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getAuditHistoryApiV1IdentityBulkimportAuditGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Récupère un template CSV pour un domaine donné.  Args:     domain: Domaine (student, parent, teacher, admin_staff)
         * @summary Get Csv Template
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCsvTemplateApiV1IdentityBulkimportTemplateDomainGet(domain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCsvTemplateApiV1IdentityBulkimportTemplateDomainGet(domain, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getCsvTemplateApiV1IdentityBulkimportTemplateDomainGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Endpoint de vérification de santé du service.
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthCheckHealthGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthCheckHealthGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.healthCheckHealthGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Endpoint racine pour vérifier que le service fonctionne.
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rootGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rootGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.rootGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Import en masse d\'identités via fichier CSV.       Accepte les formats CSV avec les schémas suivants :  - **students.csv** : establishment_id;firstname;lastname;birth_date;gender;level;account_required;email;phone  - **parents.csv** : establishment_id;firstname;lastname;email;phone  - **teachers.csv** : establishment_id;firstname;lastname;email;phone;subject;hire_date  - **admin_staff.csv** : establishment_id;firstname;lastname;email;phone;position;hire_date    Note: L\'external_id (ID Keycloak) sera automatiquement généré lors de la création du compte.    Le domaine est automatiquement détecté à partir des en-têtes du CSV.
         * @summary Bulk Import Identities
         * @param {File} file Fichier CSV à importer
         * @param {string} establishmentId ID de l\\\&#39;établissement
         * @param {string | null} [sourceFileUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkImportIdentitiesApiV1IdentityBulkimportPost(file: File, establishmentId: string, sourceFileUrl?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<BulkImportResponse> {
            return localVarFp.bulkImportIdentitiesApiV1IdentityBulkimportPost(file, establishmentId, sourceFileUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère l\'historique d\'audit des opérations de bulk import.  Args:     user_id: Filtrer par utilisateur     establishment_id: Filtrer par établissement     batch_id: Filtrer par batch     limit: Limite du nombre de résultats
         * @summary Get Audit History
         * @param {string | null} [userId] 
         * @param {string | null} [establishmentId] 
         * @param {string | null} [batchId] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditHistoryApiV1IdentityBulkimportAuditGet(userId?: string | null, establishmentId?: string | null, batchId?: string | null, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getAuditHistoryApiV1IdentityBulkimportAuditGet(userId, establishmentId, batchId, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère un template CSV pour un domaine donné.  Args:     domain: Domaine (student, parent, teacher, admin_staff)
         * @summary Get Csv Template
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCsvTemplateApiV1IdentityBulkimportTemplateDomainGet(domain: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getCsvTemplateApiV1IdentityBulkimportTemplateDomainGet(domain, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint de vérification de santé du service.
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheckHealthGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.healthCheckHealthGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint racine pour vérifier que le service fonctionne.
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.rootGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Import en masse d\'identités via fichier CSV.       Accepte les formats CSV avec les schémas suivants :  - **students.csv** : establishment_id;firstname;lastname;birth_date;gender;level;account_required;email;phone  - **parents.csv** : establishment_id;firstname;lastname;email;phone  - **teachers.csv** : establishment_id;firstname;lastname;email;phone;subject;hire_date  - **admin_staff.csv** : establishment_id;firstname;lastname;email;phone;position;hire_date    Note: L\'external_id (ID Keycloak) sera automatiquement généré lors de la création du compte.    Le domaine est automatiquement détecté à partir des en-têtes du CSV.
     * @summary Bulk Import Identities
     * @param {File} file Fichier CSV à importer
     * @param {string} establishmentId ID de l\\\&#39;établissement
     * @param {string | null} [sourceFileUrl] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public bulkImportIdentitiesApiV1IdentityBulkimportPost(file: File, establishmentId: string, sourceFileUrl?: string | null, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).bulkImportIdentitiesApiV1IdentityBulkimportPost(file, establishmentId, sourceFileUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère l\'historique d\'audit des opérations de bulk import.  Args:     user_id: Filtrer par utilisateur     establishment_id: Filtrer par établissement     batch_id: Filtrer par batch     limit: Limite du nombre de résultats
     * @summary Get Audit History
     * @param {string | null} [userId] 
     * @param {string | null} [establishmentId] 
     * @param {string | null} [batchId] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAuditHistoryApiV1IdentityBulkimportAuditGet(userId?: string | null, establishmentId?: string | null, batchId?: string | null, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAuditHistoryApiV1IdentityBulkimportAuditGet(userId, establishmentId, batchId, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère un template CSV pour un domaine donné.  Args:     domain: Domaine (student, parent, teacher, admin_staff)
     * @summary Get Csv Template
     * @param {string} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCsvTemplateApiV1IdentityBulkimportTemplateDomainGet(domain: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCsvTemplateApiV1IdentityBulkimportTemplateDomainGet(domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint de vérification de santé du service.
     * @summary Health Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public healthCheckHealthGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).healthCheckHealthGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint racine pour vérifier que le service fonctionne.
     * @summary Root
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rootGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rootGet(options).then((request) => request(this.axios, this.basePath));
    }
}



