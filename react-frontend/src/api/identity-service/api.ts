/* tslint:disable */
/* eslint-disable */
/**
 * identity-service
 * Service de gestion des identités - Bulk Import et Traçabilité
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Requête pour la sélection de contexte.  Utilisée par le frontend pour valider le contexte choisi avant que auth-service injecte les en-têtes.
 * @export
 * @interface ContextSelectRequest
 */
export interface ContextSelectRequest {
    /**
     * UUID de l\'établissement
     * @type {string}
     * @memberof ContextSelectRequest
     */
    'etab_id': string;
    /**
     * Code du rôle principal
     * @type {string}
     * @memberof ContextSelectRequest
     */
    'role': string;
}
/**
 * Réponse pour la sélection de contexte.  Confirme que le contexte est valide et peut être utilisé.
 * @export
 * @interface ContextSelectResponse
 */
export interface ContextSelectResponse {
    /**
     * Contexte validé avec succès
     * @type {boolean}
     * @memberof ContextSelectResponse
     */
    'success'?: boolean;
    /**
     * Message de confirmation
     * @type {string}
     * @memberof ContextSelectResponse
     */
    'message'?: string;
}
/**
 * Information sur un cycle.
 * @export
 * @interface CycleInfo
 */
export interface CycleInfo {
    /**
     * ID du cycle
     * @type {string}
     * @memberof CycleInfo
     */
    'id': string;
    /**
     * Code du cycle
     * @type {string}
     * @memberof CycleInfo
     */
    'code': string;
    /**
     * Clé de libellé du cycle
     * @type {string}
     * @memberof CycleInfo
     */
    'label_key': string;
    /**
     * Ordre de tri
     * @type {number}
     * @memberof CycleInfo
     */
    'sort_order': number;
}
/**
 * Réponse d\'erreur standardisée.
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * Message d\'erreur
     * @type {string}
     * @memberof ErrorResponse
     */
    'detail': string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'code'?: string | null;
}
/**
 * Schéma pour la création d\'un lien avec un établissement (version enrichie).
 * @export
 * @interface EstablishmentLinkCreate
 */
export interface EstablishmentLinkCreate {
    /**
     * ID de l\'établissement
     * @type {string}
     * @memberof EstablishmentLinkCreate
     */
    'establishment_id': string;
    /**
     * Code du rôle principal (ex: \'teacher\')
     * @type {string}
     * @memberof EstablishmentLinkCreate
     */
    'role_principal_code': string;
    /**
     * 
     * @type {string}
     * @memberof EstablishmentLinkCreate
     */
    'role_effectif_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EstablishmentLinkCreate
     */
    'function_display'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof EstablishmentLinkCreate
     */
    'cycle_codes'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof EstablishmentLinkCreate
     */
    'subject_codes'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * Schéma pour la création d\'une identité avec code fourni.
 * @export
 * @interface IdentityCreate
 */
export interface IdentityCreate {
    /**
     * Prénom
     * @type {string}
     * @memberof IdentityCreate
     */
    'firstname': string;
    /**
     * Nom de famille
     * @type {string}
     * @memberof IdentityCreate
     */
    'lastname': string;
    /**
     * 
     * @type {string}
     * @memberof IdentityCreate
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IdentityCreate
     */
    'phone'?: string | null;
    /**
     * Statut de l\'identité
     * @type {IdentityStatus}
     * @memberof IdentityCreate
     */
    'status'?: IdentityStatus;
    /**
     * 
     * @type {string}
     * @memberof IdentityCreate
     */
    'account_required'?: string | null;
    /**
     * Code d\'identité fourni par le client
     * @type {string}
     * @memberof IdentityCreate
     */
    'code_identite': string;
    /**
     * 
     * @type {string}
     * @memberof IdentityCreate
     */
    'external_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IdentityCreate
     */
    'establishment_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IdentityCreate
     */
    'role_principal_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IdentityCreate
     */
    'role_effectif_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IdentityCreate
     */
    'function_display'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof IdentityCreate
     */
    'cycle_codes'?: Array<string> | null;
}


/**
 * Énumération des statuts possibles pour une identité.
 * @export
 * @enum {string}
 */

export const IdentityStatus = {
    Active: 'ACTIVE',
    Archived: 'ARCHIVED',
    Transferred: 'TRANSFERRED'
} as const;

export type IdentityStatus = typeof IdentityStatus[keyof typeof IdentityStatus];


/**
 * Schéma pour la modification partielle d\'une identité avec rôles.
 * @export
 * @interface IdentityUpdate
 */
export interface IdentityUpdate {
    /**
     * 
     * @type {string}
     * @memberof IdentityUpdate
     */
    'firstname'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IdentityUpdate
     */
    'lastname'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IdentityUpdate
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IdentityUpdate
     */
    'phone'?: string | null;
    /**
     * 
     * @type {IdentityStatus}
     * @memberof IdentityUpdate
     */
    'status'?: IdentityStatus | null;
    /**
     * 
     * @type {string}
     * @memberof IdentityUpdate
     */
    'account_required'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IdentityUpdate
     */
    'establishment_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IdentityUpdate
     */
    'role_principal_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IdentityUpdate
     */
    'role_effectif_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IdentityUpdate
     */
    'function_display'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof IdentityUpdate
     */
    'cycle_codes'?: Array<string> | null;
}


/**
 * Schéma pour une identité avec ses rôles complexes.
 * @export
 * @interface IdentityWithRoles
 */
export interface IdentityWithRoles {
    /**
     * ID de l\'identité
     * @type {string}
     * @memberof IdentityWithRoles
     */
    'id': string;
    /**
     * Prénom
     * @type {string}
     * @memberof IdentityWithRoles
     */
    'firstname': string;
    /**
     * Nom de famille
     * @type {string}
     * @memberof IdentityWithRoles
     */
    'lastname': string;
    /**
     * 
     * @type {string}
     * @memberof IdentityWithRoles
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IdentityWithRoles
     */
    'phone'?: string | null;
    /**
     * Statut de l\'identité
     * @type {string}
     * @memberof IdentityWithRoles
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof IdentityWithRoles
     */
    'external_id'?: string | null;
    /**
     * Date de création
     * @type {string}
     * @memberof IdentityWithRoles
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof IdentityWithRoles
     */
    'updated_at'?: string | null;
    /**
     * Rôles complexes de l\'identité
     * @type {Array<RoleAssignmentResponse>}
     * @memberof IdentityWithRoles
     */
    'role_assignments'?: Array<RoleAssignmentResponse>;
}
/**
 * Schéma pour la réponse du dernier code utilisé.
 * @export
 * @interface LastCodeResponse
 */
export interface LastCodeResponse {
    /**
     * Dernier code d\'identité utilisé
     * @type {string}
     * @memberof LastCodeResponse
     */
    'last_code': string;
}
/**
 * Schéma pour la création d\'un rôle complexe.
 * @export
 * @interface RoleAssignmentCreate
 */
export interface RoleAssignmentCreate {
    /**
     * ID de l\'établissement
     * @type {string}
     * @memberof RoleAssignmentCreate
     */
    'establishment_id': string;
    /**
     * Code du rôle principal
     * @type {string}
     * @memberof RoleAssignmentCreate
     */
    'role_principal_code': string;
    /**
     * 
     * @type {string}
     * @memberof RoleAssignmentCreate
     */
    'role_effectif_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RoleAssignmentCreate
     */
    'function_display'?: string | null;
    /**
     * Codes des cycles
     * @type {Array<string>}
     * @memberof RoleAssignmentCreate
     */
    'cycle_codes'?: Array<string>;
    /**
     * Codes des matières
     * @type {Array<string>}
     * @memberof RoleAssignmentCreate
     */
    'subject_codes'?: Array<string>;
}
/**
 * Schéma pour la réponse d\'un rôle complexe.
 * @export
 * @interface RoleAssignmentResponse
 */
export interface RoleAssignmentResponse {
    /**
     * ID du rôle
     * @type {string}
     * @memberof RoleAssignmentResponse
     */
    'id': string;
    /**
     * ID du lien identité-établissement
     * @type {string}
     * @memberof RoleAssignmentResponse
     */
    'identity_establishment_id': string;
    /**
     * Rôle principal
     * @type {RolePrincipalInfo}
     * @memberof RoleAssignmentResponse
     */
    'role_principal': RolePrincipalInfo;
    /**
     * 
     * @type {RoleEffectifInfo}
     * @memberof RoleAssignmentResponse
     */
    'role_effectif'?: RoleEffectifInfo | null;
    /**
     * 
     * @type {string}
     * @memberof RoleAssignmentResponse
     */
    'function_display'?: string | null;
    /**
     * Cycles assignés
     * @type {Array<CycleInfo>}
     * @memberof RoleAssignmentResponse
     */
    'cycles'?: Array<CycleInfo>;
    /**
     * Matières assignées
     * @type {Array<SubjectInfo>}
     * @memberof RoleAssignmentResponse
     */
    'subjects'?: Array<SubjectInfo>;
    /**
     * Date de création
     * @type {string}
     * @memberof RoleAssignmentResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof RoleAssignmentResponse
     */
    'updated_at'?: string | null;
}
/**
 * Schéma pour la modification d\'un rôle complexe.
 * @export
 * @interface RoleAssignmentUpdate
 */
export interface RoleAssignmentUpdate {
    /**
     * 
     * @type {string}
     * @memberof RoleAssignmentUpdate
     */
    'role_effectif_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RoleAssignmentUpdate
     */
    'function_display'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof RoleAssignmentUpdate
     */
    'cycle_codes'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof RoleAssignmentUpdate
     */
    'subject_codes'?: Array<string> | null;
}
/**
 * Information sur un rôle effectif.
 * @export
 * @interface RoleEffectifInfo
 */
export interface RoleEffectifInfo {
    /**
     * ID du rôle effectif
     * @type {string}
     * @memberof RoleEffectifInfo
     */
    'id': string;
    /**
     * Code du rôle effectif
     * @type {string}
     * @memberof RoleEffectifInfo
     */
    'code': string;
    /**
     * Clé de libellé du rôle effectif
     * @type {string}
     * @memberof RoleEffectifInfo
     */
    'label_key': string;
    /**
     * Groupe du rôle effectif
     * @type {string}
     * @memberof RoleEffectifInfo
     */
    'group_key': string;
    /**
     * Rôle sensible
     * @type {boolean}
     * @memberof RoleEffectifInfo
     */
    'is_sensitive': boolean;
    /**
     * Ordre de tri
     * @type {number}
     * @memberof RoleEffectifInfo
     */
    'sort_order': number;
}
/**
 * Information sur un rôle principal.
 * @export
 * @interface RolePrincipalInfo
 */
export interface RolePrincipalInfo {
    /**
     * ID du rôle principal
     * @type {string}
     * @memberof RolePrincipalInfo
     */
    'id': string;
    /**
     * Code du rôle principal
     * @type {string}
     * @memberof RolePrincipalInfo
     */
    'code': string;
    /**
     * Clé de libellé du rôle principal
     * @type {string}
     * @memberof RolePrincipalInfo
     */
    'label_key': string;
    /**
     * Ordre de tri
     * @type {number}
     * @memberof RolePrincipalInfo
     */
    'sort_order': number;
}
/**
 * Format standardisé pour les réponses contenant une liste d\'éléments.  Utilisé pour : GET /identities, GET /catalogs/_*, GET /me/roles, etc.
 * @export
 * @interface StandardListResponse
 */
export interface StandardListResponse {
    /**
     * Indique si l\'opération a réussi
     * @type {boolean}
     * @memberof StandardListResponse
     */
    'success'?: boolean;
    /**
     * Liste des données
     * @type {Array<any>}
     * @memberof StandardListResponse
     */
    'data': Array<any>;
    /**
     * Nombre total d\'éléments
     * @type {number}
     * @memberof StandardListResponse
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof StandardListResponse
     */
    'page'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof StandardListResponse
     */
    'page_size'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof StandardListResponse
     */
    'pages'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof StandardListResponse
     */
    'message'?: string | null;
    /**
     * Horodatage de la réponse
     * @type {string}
     * @memberof StandardListResponse
     */
    'timestamp'?: string;
}
/**
 * Format standardisé pour les réponses contenant un seul élément.  Utilisé pour : GET /identities/{id}, GET /roles/{id}, etc.
 * @export
 * @interface StandardSingleResponse
 */
export interface StandardSingleResponse {
    /**
     * Indique si l\'opération a réussi
     * @type {boolean}
     * @memberof StandardSingleResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {any}
     * @memberof StandardSingleResponse
     */
    'data': any;
    /**
     * 
     * @type {string}
     * @memberof StandardSingleResponse
     */
    'message'?: string | null;
    /**
     * Horodatage de la réponse
     * @type {string}
     * @memberof StandardSingleResponse
     */
    'timestamp'?: string;
}
/**
 * Format standardisé pour les réponses de succès (opérations de création/modification).  Utilisé pour : POST /identities, PUT /identities/{id}, DELETE /identities/{id}, etc.
 * @export
 * @interface StandardSuccessResponse
 */
export interface StandardSuccessResponse {
    /**
     * Indique que l\'opération a réussi
     * @type {boolean}
     * @memberof StandardSuccessResponse
     */
    'success'?: boolean;
    /**
     * Message de succès
     * @type {string}
     * @memberof StandardSuccessResponse
     */
    'message': string;
    /**
     * Données optionnelles de la réponse
     * @type {}
     * @memberof StandardSuccessResponse
     */
    'data'?:  | null;
    /**
     * Horodatage de la réponse
     * @type {string}
     * @memberof StandardSuccessResponse
     */
    'timestamp'?: string;
}
/**
 * Information sur une matière.
 * @export
 * @interface SubjectInfo
 */
export interface SubjectInfo {
    /**
     * ID de la matière
     * @type {string}
     * @memberof SubjectInfo
     */
    'id': string;
    /**
     * Code de la matière
     * @type {string}
     * @memberof SubjectInfo
     */
    'code': string;
    /**
     * Clé de libellé de la matière
     * @type {string}
     * @memberof SubjectInfo
     */
    'label_key': string;
    /**
     * Ordre de tri
     * @type {number}
     * @memberof SubjectInfo
     */
    'sort_order': number;
}
/**
 * Informations sur un template.
 * @export
 * @interface TemplateInfo
 */
export interface TemplateInfo {
    /**
     * Rôle du template
     * @type {string}
     * @memberof TemplateInfo
     */
    'role': string;
    /**
     * Format du template (csv ou xlsx)
     * @type {string}
     * @memberof TemplateInfo
     */
    'format': string;
    /**
     * Colonnes du template
     * @type {Array<string>}
     * @memberof TemplateInfo
     */
    'columns': Array<string>;
    /**
     * Données d\'exemple
     * @type {Array<{ [key: string]: any; }>}
     * @memberof TemplateInfo
     */
    'example_data': Array<{ [key: string]: any; }>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof TemplateInfo
     */
    'role_mapping'?: { [key: string]: any; } | null;
}
/**
 * Réponse pour l\'export de template.
 * @export
 * @interface TemplateResponse
 */
export interface TemplateResponse {
    /**
     * True si l\'export s\'est bien déroulé
     * @type {boolean}
     * @memberof TemplateResponse
     */
    'success': boolean;
    /**
     * Message de l\'export
     * @type {string}
     * @memberof TemplateResponse
     */
    'message': string;
    /**
     * Informations sur le template
     * @type {TemplateInfo}
     * @memberof TemplateResponse
     */
    'template_info': TemplateInfo;
    /**
     * 
     * @type {string}
     * @memberof TemplateResponse
     */
    'download_url'?: string | null;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<ValidationErrorLocInner>}
     * @memberof ValidationError
     */
    'loc': Array<ValidationErrorLocInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Import en masse d\'identités via fichier CSV ou Excel.  **Formats supportés :** - **CSV** : Fichier avec séparateur point-virgule (;) - **Excel** : Fichier .xlsx avec onglets (identities, roles, cycles)  **Colonnes attendues :** - `nom` : Nom de famille (requis) - `prenom` : Prénom (requis) - `email` : Adresse email (requis, unique) - `numero_telephone` : Numéro de téléphone (optionnel, unique si fourni) - `role_principal` : Rôle principal (student, parent, teacher, admin_staff) - `role_effectif` : Rôle effectif (optionnel) - `cycle` : Cycles couverts, séparés par virgules (ex: primary,middle)  **Exemple de fichier CSV :** ```csv nom;prenom;email;numero_telephone;role_principal;role_effectif;cycle Martin;Jean;jean.martin@example.com;0123456789;student;;primary Bernard;Marie;marie.bernard@example.com;0987654321;teacher;prof_principal;primary,middle ```  **Exemple de fichier Excel :** - Onglet \"identities\" : Données de base des identités - Onglet \"roles\" : Rôles et établissements - Onglet \"cycles\" : Cycles couverts par chaque identité  **Établissement :** - L\'établissement est fourni via le paramètre `establishment_id` du formulaire - Toutes les identités du fichier seront associées à cet établissement - Pas besoin de spécifier l\'établissement dans le fichier  **Réponse :** - Rapport détaillé de l\'import - Statistiques (succès, erreurs, nouvelles identités) - Détails par identité traitée - Erreurs de validation des établissements
         * @summary Bulk Import Identities
         * @param {File} file Fichier CSV ou Excel à importer
         * @param {string | null} [establishmentId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkImportIdentitiesApiV1IdentityBulkimportPost: async (file: File, establishmentId?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('bulkImportIdentitiesApiV1IdentityBulkimportPost', 'file', file)
            const localVarPath = `/api/v1/identity/bulkimport`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (establishmentId !== undefined) { 
                localVarFormParams.append('establishment_id', establishmentId as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Crée une nouvelle identité.  Args:     identity_data: Données de l\'identité à créer     identity_crud_service: Service CRUD des identités     tenant_context: Contexte tenant avec rôles et établissement      Returns:     IdentityResponse: Identité créée
         * @summary Create Identity
         * @param {IdentityCreate} identityCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIdentityApiV1IdentityPost: async (identityCreate: IdentityCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityCreate' is not null or undefined
            assertParamExists('createIdentityApiV1IdentityPost', 'identityCreate', identityCreate)
            const localVarPath = `/api/v1/identity/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identityCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Crée un nouveau rôle complexe pour une identité.  Args:     identity_id: ID de l\'identité     role_data: Données du rôle à créer      Returns:     RoleAssignmentResponse: Rôle créé avec succès
         * @summary Create Role Assignment
         * @param {string} identityId 
         * @param {RoleAssignmentCreate} roleAssignmentCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesPost: async (identityId: string, roleAssignmentCreate: RoleAssignmentCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('createRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesPost', 'identityId', identityId)
            // verify required parameter 'roleAssignmentCreate' is not null or undefined
            assertParamExists('createRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesPost', 'roleAssignmentCreate', roleAssignmentCreate)
            const localVarPath = `/api/v1/identity/identities/{identity_id}/roles`
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleAssignmentCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Supprime une identité.  Args:     identity_id: ID de l\'identité à supprimer     identity_crud_service: Service CRUD des identités     tenant_context: Contexte tenant avec rôles et établissement      Returns:     Dict: Message de confirmation
         * @summary Delete Identity
         * @param {string} identityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentityApiV1IdentityIdentityIdDelete: async (identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('deleteIdentityApiV1IdentityIdentityIdDelete', 'identityId', identityId)
            const localVarPath = `/api/v1/identity/{identity_id}`
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Supprime un rôle complexe d\'une identité.  Args:     identity_id: ID de l\'identité     role_id: ID du rôle      Returns:     dict: Message de confirmation
         * @summary Delete Role Assignment
         * @param {string} identityId 
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesRoleIdDelete: async (identityId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('deleteRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesRoleIdDelete', 'identityId', identityId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('deleteRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesRoleIdDelete', 'roleId', roleId)
            const localVarPath = `/api/v1/identity/identities/{identity_id}/roles/{role_id}`
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère les détails d\'un batch spécifique.  Args:     batch_id: ID du batch      Returns:     Dict: Détails du batch
         * @summary Get Batch Details
         * @param {string} batchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchDetailsApiV1IdentityBulkimportBatchesBatchIdGet: async (batchId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('getBatchDetailsApiV1IdentityBulkimportBatchesBatchIdGet', 'batchId', batchId)
            const localVarPath = `/api/v1/identity/bulkimport/batches/{batch_id}`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère les erreurs d\'un batch avec pagination et filtres.  Args:     batch_id: ID du batch     page: Numéro de page (défaut: 1)     size: Taille de page (défaut: 50, max: 200)     error_type: Filtrer par type d\'erreur      Returns:     Dict: Erreurs paginées avec métadonnées
         * @summary Get Batch Errors
         * @param {string} batchId 
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de page
         * @param {string | null} [errorType] Filtrer par type d\&#39;erreur (VALIDATION, DUPLICATE, DATABASE, etc.)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchErrorsApiV1IdentityBulkimportBatchesBatchIdErrorsGet: async (batchId: string, page?: number, size?: number, errorType?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('getBatchErrorsApiV1IdentityBulkimportBatchesBatchIdErrorsGet', 'batchId', batchId)
            const localVarPath = `/api/v1/identity/bulkimport/batches/{batch_id}/errors`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (errorType !== undefined) {
                localVarQueryParameter['error_type'] = errorType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère les items d\'un batch avec pagination et filtres.  Args:     batch_id: ID du batch     page: Numéro de page (défaut: 1)     size: Taille de page (défaut: 50, max: 200)     status: Filtrer par statut     search: Rechercher par email      Returns:     Dict: Items paginés avec métadonnées
         * @summary Get Batch Items
         * @param {string} batchId 
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de page
         * @param {string | null} [status] Filtrer par statut (PENDING, PROCESSING, SUCCESS, ERROR, SKIPPED)
         * @param {string | null} [search] Rechercher par email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchItemsApiV1IdentityBulkimportBatchesBatchIdItemsGet: async (batchId: string, page?: number, size?: number, status?: string | null, search?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('getBatchItemsApiV1IdentityBulkimportBatchesBatchIdItemsGet', 'batchId', batchId)
            const localVarPath = `/api/v1/identity/bulkimport/batches/{batch_id}/items`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère le statut actuel d\'un batch.  Args:     batch_id: ID du batch      Returns:     Dict: Statut du batch
         * @summary Get Batch Status
         * @param {string} batchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchStatusApiV1IdentityBulkimportBatchesBatchIdStatusGet: async (batchId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('getBatchStatusApiV1IdentityBulkimportBatchesBatchIdStatusGet', 'batchId', batchId)
            const localVarPath = `/api/v1/identity/bulkimport/batches/{batch_id}/status`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère la liste des cycles pédagogiques.  Args:     page: Numéro de page     size: Taille de la page     search: Terme de recherche     is_active: Filtrer par statut actif     db: Session de base de données      Returns:     List[CycleResponse]: Liste des cycles
         * @summary Get Cycles
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de la page
         * @param {string | null} [search] Terme de recherche
         * @param {boolean | null} [isActive] Filtrer par statut actif
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getCyclesApiV1IdentityCatalogsCycleGet: async (page?: number, size?: number, search?: string | null, isActive?: boolean | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/identity/catalogs/cycle`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère la liste des cycles pédagogiques.  Args:     page: Numéro de page     size: Taille de la page     search: Terme de recherche     is_active: Filtrer par statut actif     db: Session de base de données      Returns:     List[CycleResponse]: Liste des cycles
         * @summary Get Cycles
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de la page
         * @param {string | null} [search] Terme de recherche
         * @param {boolean | null} [isActive] Filtrer par statut actif
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCyclesApiV1IdentityCatalogsCyclesGet: async (page?: number, size?: number, search?: string | null, isActive?: boolean | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/identity/catalogs/cycles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère une identité par son ID.  Args:     identity_id: ID de l\'identité     identity_crud_service: Service CRUD des identités     tenant_context: Contexte tenant avec rôles et établissement      Returns:     IdentityResponse: Identité trouvée
         * @summary Get Identity
         * @param {string} identityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityApiV1IdentityIdentityIdGet: async (identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('getIdentityApiV1IdentityIdentityIdGet', 'identityId', identityId)
            const localVarPath = `/api/v1/identity/{identity_id}`
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère tous les rôles d\'une identité.  Args:     identity_id: ID de l\'identité     establishment_id: ID de l\'établissement (optionnel)      Returns:     List[RoleAssignmentResponse]: Liste des rôles de l\'identité
         * @summary Get Identity Roles
         * @param {string} identityId 
         * @param {string | null} [establishmentId] Filtrer par établissement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityRolesApiV1IdentityIdentitiesIdentityIdRolesGet: async (identityId: string, establishmentId?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('getIdentityRolesApiV1IdentityIdentitiesIdentityIdRolesGet', 'identityId', identityId)
            const localVarPath = `/api/v1/identity/identities/{identity_id}/roles`
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (establishmentId !== undefined) {
                localVarQueryParameter['establishment_id'] = establishmentId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère une identité avec tous ses rôles complexes.  Args:     identity_id: ID de l\'identité      Returns:     IdentityWithRoles: Identité avec ses rôles
         * @summary Get Identity With Roles
         * @param {string} identityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityWithRolesApiV1IdentityIdentitiesIdentityIdFullGet: async (identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('getIdentityWithRolesApiV1IdentityIdentitiesIdentityIdFullGet', 'identityId', identityId)
            const localVarPath = `/api/v1/identity/identities/{identity_id}/full`
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Exporter un template pour l\'import d\'identités.  **Rôles supportés :** - `admin_staff` : Personnel administratif - `teacher` : Enseignants - `student` : Élèves - `parent` : Parents  **Formats supportés :** - `csv` : Fichier CSV avec séparateur point-virgule - `xlsx` : Fichier Excel avec onglet  **Colonnes du template (standardisées) :** - `lastname` : Nom de famille - `firstname` : Prénom - `email` : Adresse email - `phone` : Numéro de téléphone - `role_principal` : Rôle principal (student, parent, teacher, admin_staff) - `role_effectif` : Rôle effectif (optionnel) - `cycle` : Liste de cycles parmi `preschool, primary, middle, high` (séparés par virgules) - `class_code` et `school_year` : pour teacher/student (optionnels pour admin_staff/parent) - `birth_date`, `gender`, `level`, `account_required` : champs additionnels pour student  **Exemples inclus :** Chaque template contient 2 lignes d\'exemple pour montrer la structure des données attendue.  **Établissement :** - L\'établissement est fourni via le paramètre `establishment_id` du formulaire - Toutes les identités du fichier seront associées à cet établissement - Pas besoin de spécifier l\'établissement dans le fichier  **Réponse :** - Fichier téléchargeable au format demandé - Headers appropriés pour le téléchargement
         * @summary Get Import Template
         * @param {string} role 
         * @param {string} [formatType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImportTemplateApiV1IdentityBulkimportTemplateRoleGet: async (role: string, formatType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'role' is not null or undefined
            assertParamExists('getImportTemplateApiV1IdentityBulkimportTemplateRoleGet', 'role', role)
            const localVarPath = `/api/v1/identity/bulkimport/template/{role}`
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (formatType !== undefined) {
                localVarQueryParameter['format_type'] = formatType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère le dernier code d\'identité utilisé.  **Permissions requises :** ROLE_ADMIN, ROLE_ADMINSTAFF  **Réponse :** - Dernier code utilisé uniquement (format: {\"last_code\": \"IDT000001\"})
         * @summary Get Last Code Identite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastCodeIdentiteApiV1IdentityLastCodeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/identity/last-code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère un rôle spécifique d\'une identité.  Args:     identity_id: ID de l\'identité     role_id: ID du rôle      Returns:     RoleAssignmentResponse: Rôle demandé
         * @summary Get Role Assignment
         * @param {string} identityId 
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesRoleIdGet: async (identityId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('getRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesRoleIdGet', 'identityId', identityId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('getRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesRoleIdGet', 'roleId', roleId)
            const localVarPath = `/api/v1/identity/identities/{identity_id}/roles/{role_id}`
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère la liste des rôles effectifs.  Args:     page: Numéro de page     size: Taille de la page     search: Terme de recherche     group_key: Filtrer par groupe fonctionnel     is_sensitive: Filtrer par sensibilité     is_active: Filtrer par statut actif     db: Session de base de données      Returns:     List[RoleEffectifResponse]: Liste des rôles effectifs
         * @summary Get Roles Effectifs
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de la page
         * @param {string | null} [search] Terme de recherche
         * @param {string | null} [groupKey] Filtrer par groupe
         * @param {boolean | null} [isSensitive] Filtrer par sensibilité
         * @param {boolean | null} [isActive] Filtrer par statut actif
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRolesEffectifsApiV1IdentityCatalogsRolesEffectifsGet: async (page?: number, size?: number, search?: string | null, groupKey?: string | null, isSensitive?: boolean | null, isActive?: boolean | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/identity/catalogs/roles-effectifs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (groupKey !== undefined) {
                localVarQueryParameter['group_key'] = groupKey;
            }

            if (isSensitive !== undefined) {
                localVarQueryParameter['is_sensitive'] = isSensitive;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère le catalogue des rôles effectifs (DB) et le mapping par rôle principal.  Retourne:   - roles_effectifs: liste des rôles effectifs actifs (code, label_key, group_key, is_sensitive, sort_order)   - by_principal: mapping des rôles principaux vers les codes effectifs autorisés (intersection DB ∩ mapping service)
         * @summary Get Roles Effectifs Mapping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRolesEffectifsMappingApiV1IdentityCatalogsRolesEffectifsMappingGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/identity/catalogs/roles-effectifs/mapping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère la liste des rôles principaux.  Args:     page: Numéro de page     size: Taille de la page     search: Terme de recherche     is_active: Filtrer par statut actif     db: Session de base de données      Returns:     List[RolePrincipalResponse]: Liste des rôles principaux
         * @summary Get Roles Principaux
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de la page
         * @param {string | null} [search] Terme de recherche
         * @param {boolean | null} [isActive] Filtrer par statut actif
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getRolesPrincipauxApiV1IdentityCatalogsRolePrincipalGet: async (page?: number, size?: number, search?: string | null, isActive?: boolean | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/identity/catalogs/role-principal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère la liste des rôles principaux.  Args:     page: Numéro de page     size: Taille de la page     search: Terme de recherche     is_active: Filtrer par statut actif     db: Session de base de données      Returns:     List[RolePrincipalResponse]: Liste des rôles principaux
         * @summary Get Roles Principaux
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de la page
         * @param {string | null} [search] Terme de recherche
         * @param {boolean | null} [isActive] Filtrer par statut actif
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRolesPrincipauxApiV1IdentityCatalogsRolesPrincipauxGet: async (page?: number, size?: number, search?: string | null, isActive?: boolean | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/identity/catalogs/roles-principaux`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtenir les informations sur un template d\'import.  **Paramètres :** - `role` : Rôle du template (admin_staff, teacher, student, parent)  **Réponse :** - Informations sur le template - Colonnes disponibles - Nombre d\'exemples - Description du template
         * @summary Get Template Info
         * @param {string} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplateInfoApiV1IdentityBulkimportTemplateRoleInfoGet: async (role: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'role' is not null or undefined
            assertParamExists('getTemplateInfoApiV1IdentityBulkimportTemplateRoleInfoGet', 'role', role)
            const localVarPath = `/api/v1/identity/bulkimport/template/{role}/info`
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint de vérification de santé du service.
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheckHealthGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lie une identité à un établissement.  Args:     identity_id: ID de l\'identité     link_data: Données du lien     tenant_context: Contexte tenant avec rôles et établissement      Returns:     Dict: Message de confirmation
         * @summary Link Identity To Establishment
         * @param {string} identityId 
         * @param {EstablishmentLinkCreate} establishmentLinkCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkIdentityToEstablishmentApiV1IdentityIdentityIdEstablishmentsPost: async (identityId: string, establishmentLinkCreate: EstablishmentLinkCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('linkIdentityToEstablishmentApiV1IdentityIdentityIdEstablishmentsPost', 'identityId', identityId)
            // verify required parameter 'establishmentLinkCreate' is not null or undefined
            assertParamExists('linkIdentityToEstablishmentApiV1IdentityIdentityIdEstablishmentsPost', 'establishmentLinkCreate', establishmentLinkCreate)
            const localVarPath = `/api/v1/identity/{identity_id}/establishments`
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(establishmentLinkCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lister les templates d\'import disponibles.  **Réponse :** - Liste des rôles supportés - Formats disponibles pour chaque rôle - Informations générales sur les templates
         * @summary List Available Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailableTemplatesApiV1IdentityBulkimportTemplatesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/identity/bulkimport/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Liste les batches d\'import avec pagination.  Args:     page: Numéro de page (défaut: 1)     size: Taille de page (défaut: 10, max: 100)     status: Statut pour filtrer (optionnel)      Returns:     Dict: Liste paginée des batches
         * @summary List Batches
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de page
         * @param {string | null} [status] Filtrer par statut
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchesApiV1IdentityBulkimportBatchesGet: async (page?: number, size?: number, status?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/identity/bulkimport/batches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Liste les identités avec pagination et filtres.  Args:     page: Numéro de page     size: Taille de la page     search: Terme de recherche global     sort_by: Champ de tri     sort_order: Ordre de tri     firstname: Filtre par prénom     lastname: Filtre par nom     email: Filtre par email     status: Filtre par statut     establishment_id: Filtre par établissement     role: Filtre par rôle     identity_crud_service: Service CRUD des identités     tenant_context: Contexte tenant avec rôles et établissement      Returns:     IdentityListResponse: Liste paginée des identités
         * @summary List Identities
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de la page
         * @param {string | null} [search] Terme de recherche global
         * @param {string | null} [sortBy] Champ de tri
         * @param {string | null} [sortOrder] Ordre de tri
         * @param {string | null} [firstname] Filtrer par prénom
         * @param {string | null} [lastname] Filtrer par nom
         * @param {string | null} [email] Filtrer par email
         * @param {string | null} [status] Filtrer par statut
         * @param {string | null} [establishmentId] Filtrer par établissement
         * @param {string | null} [role] Filtrer par rôle
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIdentitiesApiV1IdentityGet: async (page?: number, size?: number, search?: string | null, sortBy?: string | null, sortOrder?: string | null, firstname?: string | null, lastname?: string | null, email?: string | null, status?: string | null, establishmentId?: string | null, role?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/identity/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (firstname !== undefined) {
                localVarQueryParameter['firstname'] = firstname;
            }

            if (lastname !== undefined) {
                localVarQueryParameter['lastname'] = lastname;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (establishmentId !== undefined) {
                localVarQueryParameter['establishment_id'] = establishmentId;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint racine pour vérifier que le service fonctionne.
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stream Server-Sent Events pour suivre la progression d\'un import en masse.  Args:     batch_id: ID du batch d\'import à suivre     user_id: ID de l\'utilisateur (pour l\'authentification)     timeout: Timeout de la connexion SSE en secondes      Returns:     StreamingResponse: Stream SSE avec les événements de progression      Events:     - PROGRESS: Progression de l\'import (pourcentage, éléments traités)     - COMPLETED: Import terminé avec succès     - ERROR: Erreur lors de l\'import     - CANCELLED: Import annulé     - TIMEOUT: Connexion expirée
         * @summary Stream Import Progress
         * @param {string} batchId 
         * @param {string | null} [userId] ID de l\&#39;utilisateur pour l\&#39;authentification
         * @param {number} [timeout] Timeout en secondes (défaut: 5 minutes)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamImportProgressApiV1IdentityBulkimportSseBatchIdGet: async (batchId: string, userId?: string | null, timeout?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('streamImportProgressApiV1IdentityBulkimportSseBatchIdGet', 'batchId', batchId)
            const localVarPath = `/api/v1/identity/bulkimport/sse/{batch_id}`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Supprime le lien entre une identité et un établissement.  Args:     identity_id: ID de l\'identité     establishment_id: ID de l\'établissement     identity_crud_service: Service CRUD des identités     tenant_context: Contexte tenant avec rôles et établissement      Returns:     Dict: Message de confirmation
         * @summary Unlink Identity From Establishment
         * @param {string} identityId 
         * @param {string} establishmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkIdentityFromEstablishmentApiV1IdentityIdentityIdEstablishmentsEstablishmentIdDelete: async (identityId: string, establishmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('unlinkIdentityFromEstablishmentApiV1IdentityIdentityIdEstablishmentsEstablishmentIdDelete', 'identityId', identityId)
            // verify required parameter 'establishmentId' is not null or undefined
            assertParamExists('unlinkIdentityFromEstablishmentApiV1IdentityIdentityIdEstablishmentsEstablishmentIdDelete', 'establishmentId', establishmentId)
            const localVarPath = `/api/v1/identity/{identity_id}/establishments/{establishment_id}`
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)))
                .replace(`{${"establishment_id"}}`, encodeURIComponent(String(establishmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Met à jour une identité.  Args:     identity_id: ID de l\'identité à mettre à jour     identity_data: Nouvelles données     identity_crud_service: Service CRUD des identités     tenant_context: Contexte tenant avec rôles et établissement      Returns:     IdentityResponse: Identité mise à jour
         * @summary Update Identity
         * @param {string} identityId 
         * @param {IdentityUpdate} identityUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIdentityApiV1IdentityIdentityIdPatch: async (identityId: string, identityUpdate: IdentityUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('updateIdentityApiV1IdentityIdentityIdPatch', 'identityId', identityId)
            // verify required parameter 'identityUpdate' is not null or undefined
            assertParamExists('updateIdentityApiV1IdentityIdentityIdPatch', 'identityUpdate', identityUpdate)
            const localVarPath = `/api/v1/identity/{identity_id}`
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identityUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Met à jour un rôle complexe d\'une identité.  Args:     identity_id: ID de l\'identité     role_id: ID du rôle     role_data: Nouvelles données du rôle      Returns:     RoleAssignmentResponse: Rôle mis à jour
         * @summary Update Role Assignment
         * @param {string} identityId 
         * @param {string} roleId 
         * @param {RoleAssignmentUpdate} roleAssignmentUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesRoleIdPut: async (identityId: string, roleId: string, roleAssignmentUpdate: RoleAssignmentUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('updateRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesRoleIdPut', 'identityId', identityId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('updateRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesRoleIdPut', 'roleId', roleId)
            // verify required parameter 'roleAssignmentUpdate' is not null or undefined
            assertParamExists('updateRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesRoleIdPut', 'roleAssignmentUpdate', roleAssignmentUpdate)
            const localVarPath = `/api/v1/identity/identities/{identity_id}/roles/{role_id}`
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleAssignmentUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Import en masse d\'identités via fichier CSV ou Excel.  **Formats supportés :** - **CSV** : Fichier avec séparateur point-virgule (;) - **Excel** : Fichier .xlsx avec onglets (identities, roles, cycles)  **Colonnes attendues :** - `nom` : Nom de famille (requis) - `prenom` : Prénom (requis) - `email` : Adresse email (requis, unique) - `numero_telephone` : Numéro de téléphone (optionnel, unique si fourni) - `role_principal` : Rôle principal (student, parent, teacher, admin_staff) - `role_effectif` : Rôle effectif (optionnel) - `cycle` : Cycles couverts, séparés par virgules (ex: primary,middle)  **Exemple de fichier CSV :** ```csv nom;prenom;email;numero_telephone;role_principal;role_effectif;cycle Martin;Jean;jean.martin@example.com;0123456789;student;;primary Bernard;Marie;marie.bernard@example.com;0987654321;teacher;prof_principal;primary,middle ```  **Exemple de fichier Excel :** - Onglet \"identities\" : Données de base des identités - Onglet \"roles\" : Rôles et établissements - Onglet \"cycles\" : Cycles couverts par chaque identité  **Établissement :** - L\'établissement est fourni via le paramètre `establishment_id` du formulaire - Toutes les identités du fichier seront associées à cet établissement - Pas besoin de spécifier l\'établissement dans le fichier  **Réponse :** - Rapport détaillé de l\'import - Statistiques (succès, erreurs, nouvelles identités) - Détails par identité traitée - Erreurs de validation des établissements
         * @summary Bulk Import Identities
         * @param {File} file Fichier CSV ou Excel à importer
         * @param {string | null} [establishmentId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkImportIdentitiesApiV1IdentityBulkimportPost(file: File, establishmentId?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkImportIdentitiesApiV1IdentityBulkimportPost(file, establishmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.bulkImportIdentitiesApiV1IdentityBulkimportPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Crée une nouvelle identité.  Args:     identity_data: Données de l\'identité à créer     identity_crud_service: Service CRUD des identités     tenant_context: Contexte tenant avec rôles et établissement      Returns:     IdentityResponse: Identité créée
         * @summary Create Identity
         * @param {IdentityCreate} identityCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createIdentityApiV1IdentityPost(identityCreate: IdentityCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StandardSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createIdentityApiV1IdentityPost(identityCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createIdentityApiV1IdentityPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Crée un nouveau rôle complexe pour une identité.  Args:     identity_id: ID de l\'identité     role_data: Données du rôle à créer      Returns:     RoleAssignmentResponse: Rôle créé avec succès
         * @summary Create Role Assignment
         * @param {string} identityId 
         * @param {RoleAssignmentCreate} roleAssignmentCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesPost(identityId: string, roleAssignmentCreate: RoleAssignmentCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleAssignmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesPost(identityId, roleAssignmentCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Supprime une identité.  Args:     identity_id: ID de l\'identité à supprimer     identity_crud_service: Service CRUD des identités     tenant_context: Contexte tenant avec rôles et établissement      Returns:     Dict: Message de confirmation
         * @summary Delete Identity
         * @param {string} identityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteIdentityApiV1IdentityIdentityIdDelete(identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StandardSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteIdentityApiV1IdentityIdentityIdDelete(identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteIdentityApiV1IdentityIdentityIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Supprime un rôle complexe d\'une identité.  Args:     identity_id: ID de l\'identité     role_id: ID du rôle      Returns:     dict: Message de confirmation
         * @summary Delete Role Assignment
         * @param {string} identityId 
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesRoleIdDelete(identityId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesRoleIdDelete(identityId, roleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesRoleIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Récupère les détails d\'un batch spécifique.  Args:     batch_id: ID du batch      Returns:     Dict: Détails du batch
         * @summary Get Batch Details
         * @param {string} batchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBatchDetailsApiV1IdentityBulkimportBatchesBatchIdGet(batchId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBatchDetailsApiV1IdentityBulkimportBatchesBatchIdGet(batchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getBatchDetailsApiV1IdentityBulkimportBatchesBatchIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Récupère les erreurs d\'un batch avec pagination et filtres.  Args:     batch_id: ID du batch     page: Numéro de page (défaut: 1)     size: Taille de page (défaut: 50, max: 200)     error_type: Filtrer par type d\'erreur      Returns:     Dict: Erreurs paginées avec métadonnées
         * @summary Get Batch Errors
         * @param {string} batchId 
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de page
         * @param {string | null} [errorType] Filtrer par type d\&#39;erreur (VALIDATION, DUPLICATE, DATABASE, etc.)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBatchErrorsApiV1IdentityBulkimportBatchesBatchIdErrorsGet(batchId: string, page?: number, size?: number, errorType?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBatchErrorsApiV1IdentityBulkimportBatchesBatchIdErrorsGet(batchId, page, size, errorType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getBatchErrorsApiV1IdentityBulkimportBatchesBatchIdErrorsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Récupère les items d\'un batch avec pagination et filtres.  Args:     batch_id: ID du batch     page: Numéro de page (défaut: 1)     size: Taille de page (défaut: 50, max: 200)     status: Filtrer par statut     search: Rechercher par email      Returns:     Dict: Items paginés avec métadonnées
         * @summary Get Batch Items
         * @param {string} batchId 
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de page
         * @param {string | null} [status] Filtrer par statut (PENDING, PROCESSING, SUCCESS, ERROR, SKIPPED)
         * @param {string | null} [search] Rechercher par email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBatchItemsApiV1IdentityBulkimportBatchesBatchIdItemsGet(batchId: string, page?: number, size?: number, status?: string | null, search?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBatchItemsApiV1IdentityBulkimportBatchesBatchIdItemsGet(batchId, page, size, status, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getBatchItemsApiV1IdentityBulkimportBatchesBatchIdItemsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Récupère le statut actuel d\'un batch.  Args:     batch_id: ID du batch      Returns:     Dict: Statut du batch
         * @summary Get Batch Status
         * @param {string} batchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBatchStatusApiV1IdentityBulkimportBatchesBatchIdStatusGet(batchId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBatchStatusApiV1IdentityBulkimportBatchesBatchIdStatusGet(batchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getBatchStatusApiV1IdentityBulkimportBatchesBatchIdStatusGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Récupère la liste des cycles pédagogiques.  Args:     page: Numéro de page     size: Taille de la page     search: Terme de recherche     is_active: Filtrer par statut actif     db: Session de base de données      Returns:     List[CycleResponse]: Liste des cycles
         * @summary Get Cycles
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de la page
         * @param {string | null} [search] Terme de recherche
         * @param {boolean | null} [isActive] Filtrer par statut actif
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getCyclesApiV1IdentityCatalogsCycleGet(page?: number, size?: number, search?: string | null, isActive?: boolean | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StandardListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCyclesApiV1IdentityCatalogsCycleGet(page, size, search, isActive, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getCyclesApiV1IdentityCatalogsCycleGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Récupère la liste des cycles pédagogiques.  Args:     page: Numéro de page     size: Taille de la page     search: Terme de recherche     is_active: Filtrer par statut actif     db: Session de base de données      Returns:     List[CycleResponse]: Liste des cycles
         * @summary Get Cycles
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de la page
         * @param {string | null} [search] Terme de recherche
         * @param {boolean | null} [isActive] Filtrer par statut actif
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCyclesApiV1IdentityCatalogsCyclesGet(page?: number, size?: number, search?: string | null, isActive?: boolean | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StandardListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCyclesApiV1IdentityCatalogsCyclesGet(page, size, search, isActive, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getCyclesApiV1IdentityCatalogsCyclesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Récupère une identité par son ID.  Args:     identity_id: ID de l\'identité     identity_crud_service: Service CRUD des identités     tenant_context: Contexte tenant avec rôles et établissement      Returns:     IdentityResponse: Identité trouvée
         * @summary Get Identity
         * @param {string} identityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityApiV1IdentityIdentityIdGet(identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StandardSingleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityApiV1IdentityIdentityIdGet(identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getIdentityApiV1IdentityIdentityIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Récupère tous les rôles d\'une identité.  Args:     identity_id: ID de l\'identité     establishment_id: ID de l\'établissement (optionnel)      Returns:     List[RoleAssignmentResponse]: Liste des rôles de l\'identité
         * @summary Get Identity Roles
         * @param {string} identityId 
         * @param {string | null} [establishmentId] Filtrer par établissement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityRolesApiV1IdentityIdentitiesIdentityIdRolesGet(identityId: string, establishmentId?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleAssignmentResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityRolesApiV1IdentityIdentitiesIdentityIdRolesGet(identityId, establishmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getIdentityRolesApiV1IdentityIdentitiesIdentityIdRolesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Récupère une identité avec tous ses rôles complexes.  Args:     identity_id: ID de l\'identité      Returns:     IdentityWithRoles: Identité avec ses rôles
         * @summary Get Identity With Roles
         * @param {string} identityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityWithRolesApiV1IdentityIdentitiesIdentityIdFullGet(identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityWithRoles>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityWithRolesApiV1IdentityIdentitiesIdentityIdFullGet(identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getIdentityWithRolesApiV1IdentityIdentitiesIdentityIdFullGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Exporter un template pour l\'import d\'identités.  **Rôles supportés :** - `admin_staff` : Personnel administratif - `teacher` : Enseignants - `student` : Élèves - `parent` : Parents  **Formats supportés :** - `csv` : Fichier CSV avec séparateur point-virgule - `xlsx` : Fichier Excel avec onglet  **Colonnes du template (standardisées) :** - `lastname` : Nom de famille - `firstname` : Prénom - `email` : Adresse email - `phone` : Numéro de téléphone - `role_principal` : Rôle principal (student, parent, teacher, admin_staff) - `role_effectif` : Rôle effectif (optionnel) - `cycle` : Liste de cycles parmi `preschool, primary, middle, high` (séparés par virgules) - `class_code` et `school_year` : pour teacher/student (optionnels pour admin_staff/parent) - `birth_date`, `gender`, `level`, `account_required` : champs additionnels pour student  **Exemples inclus :** Chaque template contient 2 lignes d\'exemple pour montrer la structure des données attendue.  **Établissement :** - L\'établissement est fourni via le paramètre `establishment_id` du formulaire - Toutes les identités du fichier seront associées à cet établissement - Pas besoin de spécifier l\'établissement dans le fichier  **Réponse :** - Fichier téléchargeable au format demandé - Headers appropriés pour le téléchargement
         * @summary Get Import Template
         * @param {string} role 
         * @param {string} [formatType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImportTemplateApiV1IdentityBulkimportTemplateRoleGet(role: string, formatType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImportTemplateApiV1IdentityBulkimportTemplateRoleGet(role, formatType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getImportTemplateApiV1IdentityBulkimportTemplateRoleGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Récupère le dernier code d\'identité utilisé.  **Permissions requises :** ROLE_ADMIN, ROLE_ADMINSTAFF  **Réponse :** - Dernier code utilisé uniquement (format: {\"last_code\": \"IDT000001\"})
         * @summary Get Last Code Identite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLastCodeIdentiteApiV1IdentityLastCodeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LastCodeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLastCodeIdentiteApiV1IdentityLastCodeGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getLastCodeIdentiteApiV1IdentityLastCodeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Récupère un rôle spécifique d\'une identité.  Args:     identity_id: ID de l\'identité     role_id: ID du rôle      Returns:     RoleAssignmentResponse: Rôle demandé
         * @summary Get Role Assignment
         * @param {string} identityId 
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesRoleIdGet(identityId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleAssignmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesRoleIdGet(identityId, roleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesRoleIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Récupère la liste des rôles effectifs.  Args:     page: Numéro de page     size: Taille de la page     search: Terme de recherche     group_key: Filtrer par groupe fonctionnel     is_sensitive: Filtrer par sensibilité     is_active: Filtrer par statut actif     db: Session de base de données      Returns:     List[RoleEffectifResponse]: Liste des rôles effectifs
         * @summary Get Roles Effectifs
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de la page
         * @param {string | null} [search] Terme de recherche
         * @param {string | null} [groupKey] Filtrer par groupe
         * @param {boolean | null} [isSensitive] Filtrer par sensibilité
         * @param {boolean | null} [isActive] Filtrer par statut actif
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRolesEffectifsApiV1IdentityCatalogsRolesEffectifsGet(page?: number, size?: number, search?: string | null, groupKey?: string | null, isSensitive?: boolean | null, isActive?: boolean | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StandardListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRolesEffectifsApiV1IdentityCatalogsRolesEffectifsGet(page, size, search, groupKey, isSensitive, isActive, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getRolesEffectifsApiV1IdentityCatalogsRolesEffectifsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Récupère le catalogue des rôles effectifs (DB) et le mapping par rôle principal.  Retourne:   - roles_effectifs: liste des rôles effectifs actifs (code, label_key, group_key, is_sensitive, sort_order)   - by_principal: mapping des rôles principaux vers les codes effectifs autorisés (intersection DB ∩ mapping service)
         * @summary Get Roles Effectifs Mapping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRolesEffectifsMappingApiV1IdentityCatalogsRolesEffectifsMappingGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRolesEffectifsMappingApiV1IdentityCatalogsRolesEffectifsMappingGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getRolesEffectifsMappingApiV1IdentityCatalogsRolesEffectifsMappingGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Récupère la liste des rôles principaux.  Args:     page: Numéro de page     size: Taille de la page     search: Terme de recherche     is_active: Filtrer par statut actif     db: Session de base de données      Returns:     List[RolePrincipalResponse]: Liste des rôles principaux
         * @summary Get Roles Principaux
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de la page
         * @param {string | null} [search] Terme de recherche
         * @param {boolean | null} [isActive] Filtrer par statut actif
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getRolesPrincipauxApiV1IdentityCatalogsRolePrincipalGet(page?: number, size?: number, search?: string | null, isActive?: boolean | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StandardListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRolesPrincipauxApiV1IdentityCatalogsRolePrincipalGet(page, size, search, isActive, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getRolesPrincipauxApiV1IdentityCatalogsRolePrincipalGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Récupère la liste des rôles principaux.  Args:     page: Numéro de page     size: Taille de la page     search: Terme de recherche     is_active: Filtrer par statut actif     db: Session de base de données      Returns:     List[RolePrincipalResponse]: Liste des rôles principaux
         * @summary Get Roles Principaux
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de la page
         * @param {string | null} [search] Terme de recherche
         * @param {boolean | null} [isActive] Filtrer par statut actif
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRolesPrincipauxApiV1IdentityCatalogsRolesPrincipauxGet(page?: number, size?: number, search?: string | null, isActive?: boolean | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StandardListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRolesPrincipauxApiV1IdentityCatalogsRolesPrincipauxGet(page, size, search, isActive, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getRolesPrincipauxApiV1IdentityCatalogsRolesPrincipauxGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Obtenir les informations sur un template d\'import.  **Paramètres :** - `role` : Rôle du template (admin_staff, teacher, student, parent)  **Réponse :** - Informations sur le template - Colonnes disponibles - Nombre d\'exemples - Description du template
         * @summary Get Template Info
         * @param {string} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTemplateInfoApiV1IdentityBulkimportTemplateRoleInfoGet(role: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTemplateInfoApiV1IdentityBulkimportTemplateRoleInfoGet(role, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getTemplateInfoApiV1IdentityBulkimportTemplateRoleInfoGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Endpoint de vérification de santé du service.
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthCheckHealthGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StandardSingleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthCheckHealthGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.healthCheckHealthGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lie une identité à un établissement.  Args:     identity_id: ID de l\'identité     link_data: Données du lien     tenant_context: Contexte tenant avec rôles et établissement      Returns:     Dict: Message de confirmation
         * @summary Link Identity To Establishment
         * @param {string} identityId 
         * @param {EstablishmentLinkCreate} establishmentLinkCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkIdentityToEstablishmentApiV1IdentityIdentityIdEstablishmentsPost(identityId: string, establishmentLinkCreate: EstablishmentLinkCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StandardSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.linkIdentityToEstablishmentApiV1IdentityIdentityIdEstablishmentsPost(identityId, establishmentLinkCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.linkIdentityToEstablishmentApiV1IdentityIdentityIdEstablishmentsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lister les templates d\'import disponibles.  **Réponse :** - Liste des rôles supportés - Formats disponibles pour chaque rôle - Informations générales sur les templates
         * @summary List Available Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAvailableTemplatesApiV1IdentityBulkimportTemplatesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAvailableTemplatesApiV1IdentityBulkimportTemplatesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listAvailableTemplatesApiV1IdentityBulkimportTemplatesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Liste les batches d\'import avec pagination.  Args:     page: Numéro de page (défaut: 1)     size: Taille de page (défaut: 10, max: 100)     status: Statut pour filtrer (optionnel)      Returns:     Dict: Liste paginée des batches
         * @summary List Batches
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de page
         * @param {string | null} [status] Filtrer par statut
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBatchesApiV1IdentityBulkimportBatchesGet(page?: number, size?: number, status?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBatchesApiV1IdentityBulkimportBatchesGet(page, size, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listBatchesApiV1IdentityBulkimportBatchesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Liste les identités avec pagination et filtres.  Args:     page: Numéro de page     size: Taille de la page     search: Terme de recherche global     sort_by: Champ de tri     sort_order: Ordre de tri     firstname: Filtre par prénom     lastname: Filtre par nom     email: Filtre par email     status: Filtre par statut     establishment_id: Filtre par établissement     role: Filtre par rôle     identity_crud_service: Service CRUD des identités     tenant_context: Contexte tenant avec rôles et établissement      Returns:     IdentityListResponse: Liste paginée des identités
         * @summary List Identities
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de la page
         * @param {string | null} [search] Terme de recherche global
         * @param {string | null} [sortBy] Champ de tri
         * @param {string | null} [sortOrder] Ordre de tri
         * @param {string | null} [firstname] Filtrer par prénom
         * @param {string | null} [lastname] Filtrer par nom
         * @param {string | null} [email] Filtrer par email
         * @param {string | null} [status] Filtrer par statut
         * @param {string | null} [establishmentId] Filtrer par établissement
         * @param {string | null} [role] Filtrer par rôle
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listIdentitiesApiV1IdentityGet(page?: number, size?: number, search?: string | null, sortBy?: string | null, sortOrder?: string | null, firstname?: string | null, lastname?: string | null, email?: string | null, status?: string | null, establishmentId?: string | null, role?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StandardListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIdentitiesApiV1IdentityGet(page, size, search, sortBy, sortOrder, firstname, lastname, email, status, establishmentId, role, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listIdentitiesApiV1IdentityGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Endpoint racine pour vérifier que le service fonctionne.
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rootGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StandardSingleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rootGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.rootGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Stream Server-Sent Events pour suivre la progression d\'un import en masse.  Args:     batch_id: ID du batch d\'import à suivre     user_id: ID de l\'utilisateur (pour l\'authentification)     timeout: Timeout de la connexion SSE en secondes      Returns:     StreamingResponse: Stream SSE avec les événements de progression      Events:     - PROGRESS: Progression de l\'import (pourcentage, éléments traités)     - COMPLETED: Import terminé avec succès     - ERROR: Erreur lors de l\'import     - CANCELLED: Import annulé     - TIMEOUT: Connexion expirée
         * @summary Stream Import Progress
         * @param {string} batchId 
         * @param {string | null} [userId] ID de l\&#39;utilisateur pour l\&#39;authentification
         * @param {number} [timeout] Timeout en secondes (défaut: 5 minutes)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamImportProgressApiV1IdentityBulkimportSseBatchIdGet(batchId: string, userId?: string | null, timeout?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.streamImportProgressApiV1IdentityBulkimportSseBatchIdGet(batchId, userId, timeout, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.streamImportProgressApiV1IdentityBulkimportSseBatchIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Supprime le lien entre une identité et un établissement.  Args:     identity_id: ID de l\'identité     establishment_id: ID de l\'établissement     identity_crud_service: Service CRUD des identités     tenant_context: Contexte tenant avec rôles et établissement      Returns:     Dict: Message de confirmation
         * @summary Unlink Identity From Establishment
         * @param {string} identityId 
         * @param {string} establishmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlinkIdentityFromEstablishmentApiV1IdentityIdentityIdEstablishmentsEstablishmentIdDelete(identityId: string, establishmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StandardSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlinkIdentityFromEstablishmentApiV1IdentityIdentityIdEstablishmentsEstablishmentIdDelete(identityId, establishmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.unlinkIdentityFromEstablishmentApiV1IdentityIdentityIdEstablishmentsEstablishmentIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Met à jour une identité.  Args:     identity_id: ID de l\'identité à mettre à jour     identity_data: Nouvelles données     identity_crud_service: Service CRUD des identités     tenant_context: Contexte tenant avec rôles et établissement      Returns:     IdentityResponse: Identité mise à jour
         * @summary Update Identity
         * @param {string} identityId 
         * @param {IdentityUpdate} identityUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateIdentityApiV1IdentityIdentityIdPatch(identityId: string, identityUpdate: IdentityUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StandardSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateIdentityApiV1IdentityIdentityIdPatch(identityId, identityUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateIdentityApiV1IdentityIdentityIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Met à jour un rôle complexe d\'une identité.  Args:     identity_id: ID de l\'identité     role_id: ID du rôle     role_data: Nouvelles données du rôle      Returns:     RoleAssignmentResponse: Rôle mis à jour
         * @summary Update Role Assignment
         * @param {string} identityId 
         * @param {string} roleId 
         * @param {RoleAssignmentUpdate} roleAssignmentUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesRoleIdPut(identityId: string, roleId: string, roleAssignmentUpdate: RoleAssignmentUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleAssignmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesRoleIdPut(identityId, roleId, roleAssignmentUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesRoleIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Import en masse d\'identités via fichier CSV ou Excel.  **Formats supportés :** - **CSV** : Fichier avec séparateur point-virgule (;) - **Excel** : Fichier .xlsx avec onglets (identities, roles, cycles)  **Colonnes attendues :** - `nom` : Nom de famille (requis) - `prenom` : Prénom (requis) - `email` : Adresse email (requis, unique) - `numero_telephone` : Numéro de téléphone (optionnel, unique si fourni) - `role_principal` : Rôle principal (student, parent, teacher, admin_staff) - `role_effectif` : Rôle effectif (optionnel) - `cycle` : Cycles couverts, séparés par virgules (ex: primary,middle)  **Exemple de fichier CSV :** ```csv nom;prenom;email;numero_telephone;role_principal;role_effectif;cycle Martin;Jean;jean.martin@example.com;0123456789;student;;primary Bernard;Marie;marie.bernard@example.com;0987654321;teacher;prof_principal;primary,middle ```  **Exemple de fichier Excel :** - Onglet \"identities\" : Données de base des identités - Onglet \"roles\" : Rôles et établissements - Onglet \"cycles\" : Cycles couverts par chaque identité  **Établissement :** - L\'établissement est fourni via le paramètre `establishment_id` du formulaire - Toutes les identités du fichier seront associées à cet établissement - Pas besoin de spécifier l\'établissement dans le fichier  **Réponse :** - Rapport détaillé de l\'import - Statistiques (succès, erreurs, nouvelles identités) - Détails par identité traitée - Erreurs de validation des établissements
         * @summary Bulk Import Identities
         * @param {File} file Fichier CSV ou Excel à importer
         * @param {string | null} [establishmentId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkImportIdentitiesApiV1IdentityBulkimportPost(file: File, establishmentId?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.bulkImportIdentitiesApiV1IdentityBulkimportPost(file, establishmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Crée une nouvelle identité.  Args:     identity_data: Données de l\'identité à créer     identity_crud_service: Service CRUD des identités     tenant_context: Contexte tenant avec rôles et établissement      Returns:     IdentityResponse: Identité créée
         * @summary Create Identity
         * @param {IdentityCreate} identityCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIdentityApiV1IdentityPost(identityCreate: IdentityCreate, options?: RawAxiosRequestConfig): AxiosPromise<StandardSuccessResponse> {
            return localVarFp.createIdentityApiV1IdentityPost(identityCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Crée un nouveau rôle complexe pour une identité.  Args:     identity_id: ID de l\'identité     role_data: Données du rôle à créer      Returns:     RoleAssignmentResponse: Rôle créé avec succès
         * @summary Create Role Assignment
         * @param {string} identityId 
         * @param {RoleAssignmentCreate} roleAssignmentCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesPost(identityId: string, roleAssignmentCreate: RoleAssignmentCreate, options?: RawAxiosRequestConfig): AxiosPromise<RoleAssignmentResponse> {
            return localVarFp.createRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesPost(identityId, roleAssignmentCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Supprime une identité.  Args:     identity_id: ID de l\'identité à supprimer     identity_crud_service: Service CRUD des identités     tenant_context: Contexte tenant avec rôles et établissement      Returns:     Dict: Message de confirmation
         * @summary Delete Identity
         * @param {string} identityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentityApiV1IdentityIdentityIdDelete(identityId: string, options?: RawAxiosRequestConfig): AxiosPromise<StandardSuccessResponse> {
            return localVarFp.deleteIdentityApiV1IdentityIdentityIdDelete(identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * Supprime un rôle complexe d\'une identité.  Args:     identity_id: ID de l\'identité     role_id: ID du rôle      Returns:     dict: Message de confirmation
         * @summary Delete Role Assignment
         * @param {string} identityId 
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesRoleIdDelete(identityId: string, roleId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.deleteRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesRoleIdDelete(identityId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère les détails d\'un batch spécifique.  Args:     batch_id: ID du batch      Returns:     Dict: Détails du batch
         * @summary Get Batch Details
         * @param {string} batchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchDetailsApiV1IdentityBulkimportBatchesBatchIdGet(batchId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getBatchDetailsApiV1IdentityBulkimportBatchesBatchIdGet(batchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère les erreurs d\'un batch avec pagination et filtres.  Args:     batch_id: ID du batch     page: Numéro de page (défaut: 1)     size: Taille de page (défaut: 50, max: 200)     error_type: Filtrer par type d\'erreur      Returns:     Dict: Erreurs paginées avec métadonnées
         * @summary Get Batch Errors
         * @param {string} batchId 
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de page
         * @param {string | null} [errorType] Filtrer par type d\&#39;erreur (VALIDATION, DUPLICATE, DATABASE, etc.)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchErrorsApiV1IdentityBulkimportBatchesBatchIdErrorsGet(batchId: string, page?: number, size?: number, errorType?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getBatchErrorsApiV1IdentityBulkimportBatchesBatchIdErrorsGet(batchId, page, size, errorType, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère les items d\'un batch avec pagination et filtres.  Args:     batch_id: ID du batch     page: Numéro de page (défaut: 1)     size: Taille de page (défaut: 50, max: 200)     status: Filtrer par statut     search: Rechercher par email      Returns:     Dict: Items paginés avec métadonnées
         * @summary Get Batch Items
         * @param {string} batchId 
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de page
         * @param {string | null} [status] Filtrer par statut (PENDING, PROCESSING, SUCCESS, ERROR, SKIPPED)
         * @param {string | null} [search] Rechercher par email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchItemsApiV1IdentityBulkimportBatchesBatchIdItemsGet(batchId: string, page?: number, size?: number, status?: string | null, search?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getBatchItemsApiV1IdentityBulkimportBatchesBatchIdItemsGet(batchId, page, size, status, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère le statut actuel d\'un batch.  Args:     batch_id: ID du batch      Returns:     Dict: Statut du batch
         * @summary Get Batch Status
         * @param {string} batchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchStatusApiV1IdentityBulkimportBatchesBatchIdStatusGet(batchId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getBatchStatusApiV1IdentityBulkimportBatchesBatchIdStatusGet(batchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère la liste des cycles pédagogiques.  Args:     page: Numéro de page     size: Taille de la page     search: Terme de recherche     is_active: Filtrer par statut actif     db: Session de base de données      Returns:     List[CycleResponse]: Liste des cycles
         * @summary Get Cycles
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de la page
         * @param {string | null} [search] Terme de recherche
         * @param {boolean | null} [isActive] Filtrer par statut actif
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getCyclesApiV1IdentityCatalogsCycleGet(page?: number, size?: number, search?: string | null, isActive?: boolean | null, options?: RawAxiosRequestConfig): AxiosPromise<StandardListResponse> {
            return localVarFp.getCyclesApiV1IdentityCatalogsCycleGet(page, size, search, isActive, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère la liste des cycles pédagogiques.  Args:     page: Numéro de page     size: Taille de la page     search: Terme de recherche     is_active: Filtrer par statut actif     db: Session de base de données      Returns:     List[CycleResponse]: Liste des cycles
         * @summary Get Cycles
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de la page
         * @param {string | null} [search] Terme de recherche
         * @param {boolean | null} [isActive] Filtrer par statut actif
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCyclesApiV1IdentityCatalogsCyclesGet(page?: number, size?: number, search?: string | null, isActive?: boolean | null, options?: RawAxiosRequestConfig): AxiosPromise<StandardListResponse> {
            return localVarFp.getCyclesApiV1IdentityCatalogsCyclesGet(page, size, search, isActive, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère une identité par son ID.  Args:     identity_id: ID de l\'identité     identity_crud_service: Service CRUD des identités     tenant_context: Contexte tenant avec rôles et établissement      Returns:     IdentityResponse: Identité trouvée
         * @summary Get Identity
         * @param {string} identityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityApiV1IdentityIdentityIdGet(identityId: string, options?: RawAxiosRequestConfig): AxiosPromise<StandardSingleResponse> {
            return localVarFp.getIdentityApiV1IdentityIdentityIdGet(identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère tous les rôles d\'une identité.  Args:     identity_id: ID de l\'identité     establishment_id: ID de l\'établissement (optionnel)      Returns:     List[RoleAssignmentResponse]: Liste des rôles de l\'identité
         * @summary Get Identity Roles
         * @param {string} identityId 
         * @param {string | null} [establishmentId] Filtrer par établissement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityRolesApiV1IdentityIdentitiesIdentityIdRolesGet(identityId: string, establishmentId?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<RoleAssignmentResponse>> {
            return localVarFp.getIdentityRolesApiV1IdentityIdentitiesIdentityIdRolesGet(identityId, establishmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère une identité avec tous ses rôles complexes.  Args:     identity_id: ID de l\'identité      Returns:     IdentityWithRoles: Identité avec ses rôles
         * @summary Get Identity With Roles
         * @param {string} identityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityWithRolesApiV1IdentityIdentitiesIdentityIdFullGet(identityId: string, options?: RawAxiosRequestConfig): AxiosPromise<IdentityWithRoles> {
            return localVarFp.getIdentityWithRolesApiV1IdentityIdentitiesIdentityIdFullGet(identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * Exporter un template pour l\'import d\'identités.  **Rôles supportés :** - `admin_staff` : Personnel administratif - `teacher` : Enseignants - `student` : Élèves - `parent` : Parents  **Formats supportés :** - `csv` : Fichier CSV avec séparateur point-virgule - `xlsx` : Fichier Excel avec onglet  **Colonnes du template (standardisées) :** - `lastname` : Nom de famille - `firstname` : Prénom - `email` : Adresse email - `phone` : Numéro de téléphone - `role_principal` : Rôle principal (student, parent, teacher, admin_staff) - `role_effectif` : Rôle effectif (optionnel) - `cycle` : Liste de cycles parmi `preschool, primary, middle, high` (séparés par virgules) - `class_code` et `school_year` : pour teacher/student (optionnels pour admin_staff/parent) - `birth_date`, `gender`, `level`, `account_required` : champs additionnels pour student  **Exemples inclus :** Chaque template contient 2 lignes d\'exemple pour montrer la structure des données attendue.  **Établissement :** - L\'établissement est fourni via le paramètre `establishment_id` du formulaire - Toutes les identités du fichier seront associées à cet établissement - Pas besoin de spécifier l\'établissement dans le fichier  **Réponse :** - Fichier téléchargeable au format demandé - Headers appropriés pour le téléchargement
         * @summary Get Import Template
         * @param {string} role 
         * @param {string} [formatType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImportTemplateApiV1IdentityBulkimportTemplateRoleGet(role: string, formatType?: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getImportTemplateApiV1IdentityBulkimportTemplateRoleGet(role, formatType, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère le dernier code d\'identité utilisé.  **Permissions requises :** ROLE_ADMIN, ROLE_ADMINSTAFF  **Réponse :** - Dernier code utilisé uniquement (format: {\"last_code\": \"IDT000001\"})
         * @summary Get Last Code Identite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastCodeIdentiteApiV1IdentityLastCodeGet(options?: RawAxiosRequestConfig): AxiosPromise<LastCodeResponse> {
            return localVarFp.getLastCodeIdentiteApiV1IdentityLastCodeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère un rôle spécifique d\'une identité.  Args:     identity_id: ID de l\'identité     role_id: ID du rôle      Returns:     RoleAssignmentResponse: Rôle demandé
         * @summary Get Role Assignment
         * @param {string} identityId 
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesRoleIdGet(identityId: string, roleId: string, options?: RawAxiosRequestConfig): AxiosPromise<RoleAssignmentResponse> {
            return localVarFp.getRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesRoleIdGet(identityId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère la liste des rôles effectifs.  Args:     page: Numéro de page     size: Taille de la page     search: Terme de recherche     group_key: Filtrer par groupe fonctionnel     is_sensitive: Filtrer par sensibilité     is_active: Filtrer par statut actif     db: Session de base de données      Returns:     List[RoleEffectifResponse]: Liste des rôles effectifs
         * @summary Get Roles Effectifs
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de la page
         * @param {string | null} [search] Terme de recherche
         * @param {string | null} [groupKey] Filtrer par groupe
         * @param {boolean | null} [isSensitive] Filtrer par sensibilité
         * @param {boolean | null} [isActive] Filtrer par statut actif
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRolesEffectifsApiV1IdentityCatalogsRolesEffectifsGet(page?: number, size?: number, search?: string | null, groupKey?: string | null, isSensitive?: boolean | null, isActive?: boolean | null, options?: RawAxiosRequestConfig): AxiosPromise<StandardListResponse> {
            return localVarFp.getRolesEffectifsApiV1IdentityCatalogsRolesEffectifsGet(page, size, search, groupKey, isSensitive, isActive, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère le catalogue des rôles effectifs (DB) et le mapping par rôle principal.  Retourne:   - roles_effectifs: liste des rôles effectifs actifs (code, label_key, group_key, is_sensitive, sort_order)   - by_principal: mapping des rôles principaux vers les codes effectifs autorisés (intersection DB ∩ mapping service)
         * @summary Get Roles Effectifs Mapping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRolesEffectifsMappingApiV1IdentityCatalogsRolesEffectifsMappingGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getRolesEffectifsMappingApiV1IdentityCatalogsRolesEffectifsMappingGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère la liste des rôles principaux.  Args:     page: Numéro de page     size: Taille de la page     search: Terme de recherche     is_active: Filtrer par statut actif     db: Session de base de données      Returns:     List[RolePrincipalResponse]: Liste des rôles principaux
         * @summary Get Roles Principaux
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de la page
         * @param {string | null} [search] Terme de recherche
         * @param {boolean | null} [isActive] Filtrer par statut actif
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getRolesPrincipauxApiV1IdentityCatalogsRolePrincipalGet(page?: number, size?: number, search?: string | null, isActive?: boolean | null, options?: RawAxiosRequestConfig): AxiosPromise<StandardListResponse> {
            return localVarFp.getRolesPrincipauxApiV1IdentityCatalogsRolePrincipalGet(page, size, search, isActive, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère la liste des rôles principaux.  Args:     page: Numéro de page     size: Taille de la page     search: Terme de recherche     is_active: Filtrer par statut actif     db: Session de base de données      Returns:     List[RolePrincipalResponse]: Liste des rôles principaux
         * @summary Get Roles Principaux
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de la page
         * @param {string | null} [search] Terme de recherche
         * @param {boolean | null} [isActive] Filtrer par statut actif
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRolesPrincipauxApiV1IdentityCatalogsRolesPrincipauxGet(page?: number, size?: number, search?: string | null, isActive?: boolean | null, options?: RawAxiosRequestConfig): AxiosPromise<StandardListResponse> {
            return localVarFp.getRolesPrincipauxApiV1IdentityCatalogsRolesPrincipauxGet(page, size, search, isActive, options).then((request) => request(axios, basePath));
        },
        /**
         * Obtenir les informations sur un template d\'import.  **Paramètres :** - `role` : Rôle du template (admin_staff, teacher, student, parent)  **Réponse :** - Informations sur le template - Colonnes disponibles - Nombre d\'exemples - Description du template
         * @summary Get Template Info
         * @param {string} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplateInfoApiV1IdentityBulkimportTemplateRoleInfoGet(role: string, options?: RawAxiosRequestConfig): AxiosPromise<TemplateResponse> {
            return localVarFp.getTemplateInfoApiV1IdentityBulkimportTemplateRoleInfoGet(role, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint de vérification de santé du service.
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheckHealthGet(options?: RawAxiosRequestConfig): AxiosPromise<StandardSingleResponse> {
            return localVarFp.healthCheckHealthGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Lie une identité à un établissement.  Args:     identity_id: ID de l\'identité     link_data: Données du lien     tenant_context: Contexte tenant avec rôles et établissement      Returns:     Dict: Message de confirmation
         * @summary Link Identity To Establishment
         * @param {string} identityId 
         * @param {EstablishmentLinkCreate} establishmentLinkCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkIdentityToEstablishmentApiV1IdentityIdentityIdEstablishmentsPost(identityId: string, establishmentLinkCreate: EstablishmentLinkCreate, options?: RawAxiosRequestConfig): AxiosPromise<StandardSuccessResponse> {
            return localVarFp.linkIdentityToEstablishmentApiV1IdentityIdentityIdEstablishmentsPost(identityId, establishmentLinkCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Lister les templates d\'import disponibles.  **Réponse :** - Liste des rôles supportés - Formats disponibles pour chaque rôle - Informations générales sur les templates
         * @summary List Available Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailableTemplatesApiV1IdentityBulkimportTemplatesGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.listAvailableTemplatesApiV1IdentityBulkimportTemplatesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Liste les batches d\'import avec pagination.  Args:     page: Numéro de page (défaut: 1)     size: Taille de page (défaut: 10, max: 100)     status: Statut pour filtrer (optionnel)      Returns:     Dict: Liste paginée des batches
         * @summary List Batches
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de page
         * @param {string | null} [status] Filtrer par statut
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchesApiV1IdentityBulkimportBatchesGet(page?: number, size?: number, status?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.listBatchesApiV1IdentityBulkimportBatchesGet(page, size, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Liste les identités avec pagination et filtres.  Args:     page: Numéro de page     size: Taille de la page     search: Terme de recherche global     sort_by: Champ de tri     sort_order: Ordre de tri     firstname: Filtre par prénom     lastname: Filtre par nom     email: Filtre par email     status: Filtre par statut     establishment_id: Filtre par établissement     role: Filtre par rôle     identity_crud_service: Service CRUD des identités     tenant_context: Contexte tenant avec rôles et établissement      Returns:     IdentityListResponse: Liste paginée des identités
         * @summary List Identities
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de la page
         * @param {string | null} [search] Terme de recherche global
         * @param {string | null} [sortBy] Champ de tri
         * @param {string | null} [sortOrder] Ordre de tri
         * @param {string | null} [firstname] Filtrer par prénom
         * @param {string | null} [lastname] Filtrer par nom
         * @param {string | null} [email] Filtrer par email
         * @param {string | null} [status] Filtrer par statut
         * @param {string | null} [establishmentId] Filtrer par établissement
         * @param {string | null} [role] Filtrer par rôle
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIdentitiesApiV1IdentityGet(page?: number, size?: number, search?: string | null, sortBy?: string | null, sortOrder?: string | null, firstname?: string | null, lastname?: string | null, email?: string | null, status?: string | null, establishmentId?: string | null, role?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<StandardListResponse> {
            return localVarFp.listIdentitiesApiV1IdentityGet(page, size, search, sortBy, sortOrder, firstname, lastname, email, status, establishmentId, role, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint racine pour vérifier que le service fonctionne.
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet(options?: RawAxiosRequestConfig): AxiosPromise<StandardSingleResponse> {
            return localVarFp.rootGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Stream Server-Sent Events pour suivre la progression d\'un import en masse.  Args:     batch_id: ID du batch d\'import à suivre     user_id: ID de l\'utilisateur (pour l\'authentification)     timeout: Timeout de la connexion SSE en secondes      Returns:     StreamingResponse: Stream SSE avec les événements de progression      Events:     - PROGRESS: Progression de l\'import (pourcentage, éléments traités)     - COMPLETED: Import terminé avec succès     - ERROR: Erreur lors de l\'import     - CANCELLED: Import annulé     - TIMEOUT: Connexion expirée
         * @summary Stream Import Progress
         * @param {string} batchId 
         * @param {string | null} [userId] ID de l\&#39;utilisateur pour l\&#39;authentification
         * @param {number} [timeout] Timeout en secondes (défaut: 5 minutes)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamImportProgressApiV1IdentityBulkimportSseBatchIdGet(batchId: string, userId?: string | null, timeout?: number, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.streamImportProgressApiV1IdentityBulkimportSseBatchIdGet(batchId, userId, timeout, options).then((request) => request(axios, basePath));
        },
        /**
         * Supprime le lien entre une identité et un établissement.  Args:     identity_id: ID de l\'identité     establishment_id: ID de l\'établissement     identity_crud_service: Service CRUD des identités     tenant_context: Contexte tenant avec rôles et établissement      Returns:     Dict: Message de confirmation
         * @summary Unlink Identity From Establishment
         * @param {string} identityId 
         * @param {string} establishmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkIdentityFromEstablishmentApiV1IdentityIdentityIdEstablishmentsEstablishmentIdDelete(identityId: string, establishmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<StandardSuccessResponse> {
            return localVarFp.unlinkIdentityFromEstablishmentApiV1IdentityIdentityIdEstablishmentsEstablishmentIdDelete(identityId, establishmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Met à jour une identité.  Args:     identity_id: ID de l\'identité à mettre à jour     identity_data: Nouvelles données     identity_crud_service: Service CRUD des identités     tenant_context: Contexte tenant avec rôles et établissement      Returns:     IdentityResponse: Identité mise à jour
         * @summary Update Identity
         * @param {string} identityId 
         * @param {IdentityUpdate} identityUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIdentityApiV1IdentityIdentityIdPatch(identityId: string, identityUpdate: IdentityUpdate, options?: RawAxiosRequestConfig): AxiosPromise<StandardSuccessResponse> {
            return localVarFp.updateIdentityApiV1IdentityIdentityIdPatch(identityId, identityUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Met à jour un rôle complexe d\'une identité.  Args:     identity_id: ID de l\'identité     role_id: ID du rôle     role_data: Nouvelles données du rôle      Returns:     RoleAssignmentResponse: Rôle mis à jour
         * @summary Update Role Assignment
         * @param {string} identityId 
         * @param {string} roleId 
         * @param {RoleAssignmentUpdate} roleAssignmentUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesRoleIdPut(identityId: string, roleId: string, roleAssignmentUpdate: RoleAssignmentUpdate, options?: RawAxiosRequestConfig): AxiosPromise<RoleAssignmentResponse> {
            return localVarFp.updateRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesRoleIdPut(identityId, roleId, roleAssignmentUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Import en masse d\'identités via fichier CSV ou Excel.  **Formats supportés :** - **CSV** : Fichier avec séparateur point-virgule (;) - **Excel** : Fichier .xlsx avec onglets (identities, roles, cycles)  **Colonnes attendues :** - `nom` : Nom de famille (requis) - `prenom` : Prénom (requis) - `email` : Adresse email (requis, unique) - `numero_telephone` : Numéro de téléphone (optionnel, unique si fourni) - `role_principal` : Rôle principal (student, parent, teacher, admin_staff) - `role_effectif` : Rôle effectif (optionnel) - `cycle` : Cycles couverts, séparés par virgules (ex: primary,middle)  **Exemple de fichier CSV :** ```csv nom;prenom;email;numero_telephone;role_principal;role_effectif;cycle Martin;Jean;jean.martin@example.com;0123456789;student;;primary Bernard;Marie;marie.bernard@example.com;0987654321;teacher;prof_principal;primary,middle ```  **Exemple de fichier Excel :** - Onglet \"identities\" : Données de base des identités - Onglet \"roles\" : Rôles et établissements - Onglet \"cycles\" : Cycles couverts par chaque identité  **Établissement :** - L\'établissement est fourni via le paramètre `establishment_id` du formulaire - Toutes les identités du fichier seront associées à cet établissement - Pas besoin de spécifier l\'établissement dans le fichier  **Réponse :** - Rapport détaillé de l\'import - Statistiques (succès, erreurs, nouvelles identités) - Détails par identité traitée - Erreurs de validation des établissements
     * @summary Bulk Import Identities
     * @param {File} file Fichier CSV ou Excel à importer
     * @param {string | null} [establishmentId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public bulkImportIdentitiesApiV1IdentityBulkimportPost(file: File, establishmentId?: string | null, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).bulkImportIdentitiesApiV1IdentityBulkimportPost(file, establishmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Crée une nouvelle identité.  Args:     identity_data: Données de l\'identité à créer     identity_crud_service: Service CRUD des identités     tenant_context: Contexte tenant avec rôles et établissement      Returns:     IdentityResponse: Identité créée
     * @summary Create Identity
     * @param {IdentityCreate} identityCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createIdentityApiV1IdentityPost(identityCreate: IdentityCreate, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createIdentityApiV1IdentityPost(identityCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Crée un nouveau rôle complexe pour une identité.  Args:     identity_id: ID de l\'identité     role_data: Données du rôle à créer      Returns:     RoleAssignmentResponse: Rôle créé avec succès
     * @summary Create Role Assignment
     * @param {string} identityId 
     * @param {RoleAssignmentCreate} roleAssignmentCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesPost(identityId: string, roleAssignmentCreate: RoleAssignmentCreate, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesPost(identityId, roleAssignmentCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Supprime une identité.  Args:     identity_id: ID de l\'identité à supprimer     identity_crud_service: Service CRUD des identités     tenant_context: Contexte tenant avec rôles et établissement      Returns:     Dict: Message de confirmation
     * @summary Delete Identity
     * @param {string} identityId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteIdentityApiV1IdentityIdentityIdDelete(identityId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteIdentityApiV1IdentityIdentityIdDelete(identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Supprime un rôle complexe d\'une identité.  Args:     identity_id: ID de l\'identité     role_id: ID du rôle      Returns:     dict: Message de confirmation
     * @summary Delete Role Assignment
     * @param {string} identityId 
     * @param {string} roleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesRoleIdDelete(identityId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesRoleIdDelete(identityId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère les détails d\'un batch spécifique.  Args:     batch_id: ID du batch      Returns:     Dict: Détails du batch
     * @summary Get Batch Details
     * @param {string} batchId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBatchDetailsApiV1IdentityBulkimportBatchesBatchIdGet(batchId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBatchDetailsApiV1IdentityBulkimportBatchesBatchIdGet(batchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère les erreurs d\'un batch avec pagination et filtres.  Args:     batch_id: ID du batch     page: Numéro de page (défaut: 1)     size: Taille de page (défaut: 50, max: 200)     error_type: Filtrer par type d\'erreur      Returns:     Dict: Erreurs paginées avec métadonnées
     * @summary Get Batch Errors
     * @param {string} batchId 
     * @param {number} [page] Numéro de page
     * @param {number} [size] Taille de page
     * @param {string | null} [errorType] Filtrer par type d\&#39;erreur (VALIDATION, DUPLICATE, DATABASE, etc.)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBatchErrorsApiV1IdentityBulkimportBatchesBatchIdErrorsGet(batchId: string, page?: number, size?: number, errorType?: string | null, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBatchErrorsApiV1IdentityBulkimportBatchesBatchIdErrorsGet(batchId, page, size, errorType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère les items d\'un batch avec pagination et filtres.  Args:     batch_id: ID du batch     page: Numéro de page (défaut: 1)     size: Taille de page (défaut: 50, max: 200)     status: Filtrer par statut     search: Rechercher par email      Returns:     Dict: Items paginés avec métadonnées
     * @summary Get Batch Items
     * @param {string} batchId 
     * @param {number} [page] Numéro de page
     * @param {number} [size] Taille de page
     * @param {string | null} [status] Filtrer par statut (PENDING, PROCESSING, SUCCESS, ERROR, SKIPPED)
     * @param {string | null} [search] Rechercher par email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBatchItemsApiV1IdentityBulkimportBatchesBatchIdItemsGet(batchId: string, page?: number, size?: number, status?: string | null, search?: string | null, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBatchItemsApiV1IdentityBulkimportBatchesBatchIdItemsGet(batchId, page, size, status, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère le statut actuel d\'un batch.  Args:     batch_id: ID du batch      Returns:     Dict: Statut du batch
     * @summary Get Batch Status
     * @param {string} batchId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBatchStatusApiV1IdentityBulkimportBatchesBatchIdStatusGet(batchId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBatchStatusApiV1IdentityBulkimportBatchesBatchIdStatusGet(batchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère la liste des cycles pédagogiques.  Args:     page: Numéro de page     size: Taille de la page     search: Terme de recherche     is_active: Filtrer par statut actif     db: Session de base de données      Returns:     List[CycleResponse]: Liste des cycles
     * @summary Get Cycles
     * @param {number} [page] Numéro de page
     * @param {number} [size] Taille de la page
     * @param {string | null} [search] Terme de recherche
     * @param {boolean | null} [isActive] Filtrer par statut actif
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCyclesApiV1IdentityCatalogsCycleGet(page?: number, size?: number, search?: string | null, isActive?: boolean | null, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCyclesApiV1IdentityCatalogsCycleGet(page, size, search, isActive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère la liste des cycles pédagogiques.  Args:     page: Numéro de page     size: Taille de la page     search: Terme de recherche     is_active: Filtrer par statut actif     db: Session de base de données      Returns:     List[CycleResponse]: Liste des cycles
     * @summary Get Cycles
     * @param {number} [page] Numéro de page
     * @param {number} [size] Taille de la page
     * @param {string | null} [search] Terme de recherche
     * @param {boolean | null} [isActive] Filtrer par statut actif
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCyclesApiV1IdentityCatalogsCyclesGet(page?: number, size?: number, search?: string | null, isActive?: boolean | null, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCyclesApiV1IdentityCatalogsCyclesGet(page, size, search, isActive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère une identité par son ID.  Args:     identity_id: ID de l\'identité     identity_crud_service: Service CRUD des identités     tenant_context: Contexte tenant avec rôles et établissement      Returns:     IdentityResponse: Identité trouvée
     * @summary Get Identity
     * @param {string} identityId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getIdentityApiV1IdentityIdentityIdGet(identityId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getIdentityApiV1IdentityIdentityIdGet(identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère tous les rôles d\'une identité.  Args:     identity_id: ID de l\'identité     establishment_id: ID de l\'établissement (optionnel)      Returns:     List[RoleAssignmentResponse]: Liste des rôles de l\'identité
     * @summary Get Identity Roles
     * @param {string} identityId 
     * @param {string | null} [establishmentId] Filtrer par établissement
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getIdentityRolesApiV1IdentityIdentitiesIdentityIdRolesGet(identityId: string, establishmentId?: string | null, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getIdentityRolesApiV1IdentityIdentitiesIdentityIdRolesGet(identityId, establishmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère une identité avec tous ses rôles complexes.  Args:     identity_id: ID de l\'identité      Returns:     IdentityWithRoles: Identité avec ses rôles
     * @summary Get Identity With Roles
     * @param {string} identityId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getIdentityWithRolesApiV1IdentityIdentitiesIdentityIdFullGet(identityId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getIdentityWithRolesApiV1IdentityIdentitiesIdentityIdFullGet(identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Exporter un template pour l\'import d\'identités.  **Rôles supportés :** - `admin_staff` : Personnel administratif - `teacher` : Enseignants - `student` : Élèves - `parent` : Parents  **Formats supportés :** - `csv` : Fichier CSV avec séparateur point-virgule - `xlsx` : Fichier Excel avec onglet  **Colonnes du template (standardisées) :** - `lastname` : Nom de famille - `firstname` : Prénom - `email` : Adresse email - `phone` : Numéro de téléphone - `role_principal` : Rôle principal (student, parent, teacher, admin_staff) - `role_effectif` : Rôle effectif (optionnel) - `cycle` : Liste de cycles parmi `preschool, primary, middle, high` (séparés par virgules) - `class_code` et `school_year` : pour teacher/student (optionnels pour admin_staff/parent) - `birth_date`, `gender`, `level`, `account_required` : champs additionnels pour student  **Exemples inclus :** Chaque template contient 2 lignes d\'exemple pour montrer la structure des données attendue.  **Établissement :** - L\'établissement est fourni via le paramètre `establishment_id` du formulaire - Toutes les identités du fichier seront associées à cet établissement - Pas besoin de spécifier l\'établissement dans le fichier  **Réponse :** - Fichier téléchargeable au format demandé - Headers appropriés pour le téléchargement
     * @summary Get Import Template
     * @param {string} role 
     * @param {string} [formatType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getImportTemplateApiV1IdentityBulkimportTemplateRoleGet(role: string, formatType?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getImportTemplateApiV1IdentityBulkimportTemplateRoleGet(role, formatType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère le dernier code d\'identité utilisé.  **Permissions requises :** ROLE_ADMIN, ROLE_ADMINSTAFF  **Réponse :** - Dernier code utilisé uniquement (format: {\"last_code\": \"IDT000001\"})
     * @summary Get Last Code Identite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getLastCodeIdentiteApiV1IdentityLastCodeGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLastCodeIdentiteApiV1IdentityLastCodeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère un rôle spécifique d\'une identité.  Args:     identity_id: ID de l\'identité     role_id: ID du rôle      Returns:     RoleAssignmentResponse: Rôle demandé
     * @summary Get Role Assignment
     * @param {string} identityId 
     * @param {string} roleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesRoleIdGet(identityId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesRoleIdGet(identityId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère la liste des rôles effectifs.  Args:     page: Numéro de page     size: Taille de la page     search: Terme de recherche     group_key: Filtrer par groupe fonctionnel     is_sensitive: Filtrer par sensibilité     is_active: Filtrer par statut actif     db: Session de base de données      Returns:     List[RoleEffectifResponse]: Liste des rôles effectifs
     * @summary Get Roles Effectifs
     * @param {number} [page] Numéro de page
     * @param {number} [size] Taille de la page
     * @param {string | null} [search] Terme de recherche
     * @param {string | null} [groupKey] Filtrer par groupe
     * @param {boolean | null} [isSensitive] Filtrer par sensibilité
     * @param {boolean | null} [isActive] Filtrer par statut actif
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getRolesEffectifsApiV1IdentityCatalogsRolesEffectifsGet(page?: number, size?: number, search?: string | null, groupKey?: string | null, isSensitive?: boolean | null, isActive?: boolean | null, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getRolesEffectifsApiV1IdentityCatalogsRolesEffectifsGet(page, size, search, groupKey, isSensitive, isActive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère le catalogue des rôles effectifs (DB) et le mapping par rôle principal.  Retourne:   - roles_effectifs: liste des rôles effectifs actifs (code, label_key, group_key, is_sensitive, sort_order)   - by_principal: mapping des rôles principaux vers les codes effectifs autorisés (intersection DB ∩ mapping service)
     * @summary Get Roles Effectifs Mapping
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getRolesEffectifsMappingApiV1IdentityCatalogsRolesEffectifsMappingGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getRolesEffectifsMappingApiV1IdentityCatalogsRolesEffectifsMappingGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère la liste des rôles principaux.  Args:     page: Numéro de page     size: Taille de la page     search: Terme de recherche     is_active: Filtrer par statut actif     db: Session de base de données      Returns:     List[RolePrincipalResponse]: Liste des rôles principaux
     * @summary Get Roles Principaux
     * @param {number} [page] Numéro de page
     * @param {number} [size] Taille de la page
     * @param {string | null} [search] Terme de recherche
     * @param {boolean | null} [isActive] Filtrer par statut actif
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getRolesPrincipauxApiV1IdentityCatalogsRolePrincipalGet(page?: number, size?: number, search?: string | null, isActive?: boolean | null, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getRolesPrincipauxApiV1IdentityCatalogsRolePrincipalGet(page, size, search, isActive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère la liste des rôles principaux.  Args:     page: Numéro de page     size: Taille de la page     search: Terme de recherche     is_active: Filtrer par statut actif     db: Session de base de données      Returns:     List[RolePrincipalResponse]: Liste des rôles principaux
     * @summary Get Roles Principaux
     * @param {number} [page] Numéro de page
     * @param {number} [size] Taille de la page
     * @param {string | null} [search] Terme de recherche
     * @param {boolean | null} [isActive] Filtrer par statut actif
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getRolesPrincipauxApiV1IdentityCatalogsRolesPrincipauxGet(page?: number, size?: number, search?: string | null, isActive?: boolean | null, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getRolesPrincipauxApiV1IdentityCatalogsRolesPrincipauxGet(page, size, search, isActive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Obtenir les informations sur un template d\'import.  **Paramètres :** - `role` : Rôle du template (admin_staff, teacher, student, parent)  **Réponse :** - Informations sur le template - Colonnes disponibles - Nombre d\'exemples - Description du template
     * @summary Get Template Info
     * @param {string} role 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTemplateInfoApiV1IdentityBulkimportTemplateRoleInfoGet(role: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTemplateInfoApiV1IdentityBulkimportTemplateRoleInfoGet(role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint de vérification de santé du service.
     * @summary Health Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public healthCheckHealthGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).healthCheckHealthGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lie une identité à un établissement.  Args:     identity_id: ID de l\'identité     link_data: Données du lien     tenant_context: Contexte tenant avec rôles et établissement      Returns:     Dict: Message de confirmation
     * @summary Link Identity To Establishment
     * @param {string} identityId 
     * @param {EstablishmentLinkCreate} establishmentLinkCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public linkIdentityToEstablishmentApiV1IdentityIdentityIdEstablishmentsPost(identityId: string, establishmentLinkCreate: EstablishmentLinkCreate, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).linkIdentityToEstablishmentApiV1IdentityIdentityIdEstablishmentsPost(identityId, establishmentLinkCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lister les templates d\'import disponibles.  **Réponse :** - Liste des rôles supportés - Formats disponibles pour chaque rôle - Informations générales sur les templates
     * @summary List Available Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listAvailableTemplatesApiV1IdentityBulkimportTemplatesGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listAvailableTemplatesApiV1IdentityBulkimportTemplatesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Liste les batches d\'import avec pagination.  Args:     page: Numéro de page (défaut: 1)     size: Taille de page (défaut: 10, max: 100)     status: Statut pour filtrer (optionnel)      Returns:     Dict: Liste paginée des batches
     * @summary List Batches
     * @param {number} [page] Numéro de page
     * @param {number} [size] Taille de page
     * @param {string | null} [status] Filtrer par statut
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listBatchesApiV1IdentityBulkimportBatchesGet(page?: number, size?: number, status?: string | null, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listBatchesApiV1IdentityBulkimportBatchesGet(page, size, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Liste les identités avec pagination et filtres.  Args:     page: Numéro de page     size: Taille de la page     search: Terme de recherche global     sort_by: Champ de tri     sort_order: Ordre de tri     firstname: Filtre par prénom     lastname: Filtre par nom     email: Filtre par email     status: Filtre par statut     establishment_id: Filtre par établissement     role: Filtre par rôle     identity_crud_service: Service CRUD des identités     tenant_context: Contexte tenant avec rôles et établissement      Returns:     IdentityListResponse: Liste paginée des identités
     * @summary List Identities
     * @param {number} [page] Numéro de page
     * @param {number} [size] Taille de la page
     * @param {string | null} [search] Terme de recherche global
     * @param {string | null} [sortBy] Champ de tri
     * @param {string | null} [sortOrder] Ordre de tri
     * @param {string | null} [firstname] Filtrer par prénom
     * @param {string | null} [lastname] Filtrer par nom
     * @param {string | null} [email] Filtrer par email
     * @param {string | null} [status] Filtrer par statut
     * @param {string | null} [establishmentId] Filtrer par établissement
     * @param {string | null} [role] Filtrer par rôle
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listIdentitiesApiV1IdentityGet(page?: number, size?: number, search?: string | null, sortBy?: string | null, sortOrder?: string | null, firstname?: string | null, lastname?: string | null, email?: string | null, status?: string | null, establishmentId?: string | null, role?: string | null, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listIdentitiesApiV1IdentityGet(page, size, search, sortBy, sortOrder, firstname, lastname, email, status, establishmentId, role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint racine pour vérifier que le service fonctionne.
     * @summary Root
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rootGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rootGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stream Server-Sent Events pour suivre la progression d\'un import en masse.  Args:     batch_id: ID du batch d\'import à suivre     user_id: ID de l\'utilisateur (pour l\'authentification)     timeout: Timeout de la connexion SSE en secondes      Returns:     StreamingResponse: Stream SSE avec les événements de progression      Events:     - PROGRESS: Progression de l\'import (pourcentage, éléments traités)     - COMPLETED: Import terminé avec succès     - ERROR: Erreur lors de l\'import     - CANCELLED: Import annulé     - TIMEOUT: Connexion expirée
     * @summary Stream Import Progress
     * @param {string} batchId 
     * @param {string | null} [userId] ID de l\&#39;utilisateur pour l\&#39;authentification
     * @param {number} [timeout] Timeout en secondes (défaut: 5 minutes)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public streamImportProgressApiV1IdentityBulkimportSseBatchIdGet(batchId: string, userId?: string | null, timeout?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).streamImportProgressApiV1IdentityBulkimportSseBatchIdGet(batchId, userId, timeout, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Supprime le lien entre une identité et un établissement.  Args:     identity_id: ID de l\'identité     establishment_id: ID de l\'établissement     identity_crud_service: Service CRUD des identités     tenant_context: Contexte tenant avec rôles et établissement      Returns:     Dict: Message de confirmation
     * @summary Unlink Identity From Establishment
     * @param {string} identityId 
     * @param {string} establishmentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public unlinkIdentityFromEstablishmentApiV1IdentityIdentityIdEstablishmentsEstablishmentIdDelete(identityId: string, establishmentId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).unlinkIdentityFromEstablishmentApiV1IdentityIdentityIdEstablishmentsEstablishmentIdDelete(identityId, establishmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Met à jour une identité.  Args:     identity_id: ID de l\'identité à mettre à jour     identity_data: Nouvelles données     identity_crud_service: Service CRUD des identités     tenant_context: Contexte tenant avec rôles et établissement      Returns:     IdentityResponse: Identité mise à jour
     * @summary Update Identity
     * @param {string} identityId 
     * @param {IdentityUpdate} identityUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateIdentityApiV1IdentityIdentityIdPatch(identityId: string, identityUpdate: IdentityUpdate, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateIdentityApiV1IdentityIdentityIdPatch(identityId, identityUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Met à jour un rôle complexe d\'une identité.  Args:     identity_id: ID de l\'identité     role_id: ID du rôle     role_data: Nouvelles données du rôle      Returns:     RoleAssignmentResponse: Rôle mis à jour
     * @summary Update Role Assignment
     * @param {string} identityId 
     * @param {string} roleId 
     * @param {RoleAssignmentUpdate} roleAssignmentUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesRoleIdPut(identityId: string, roleId: string, roleAssignmentUpdate: RoleAssignmentUpdate, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateRoleAssignmentApiV1IdentityIdentitiesIdentityIdRolesRoleIdPut(identityId, roleId, roleAssignmentUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MeContexteUtilisateurApi - axios parameter creator
 * @export
 */
export const MeContexteUtilisateurApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Récupère la liste des établissements auxquels l\'utilisateur est rattaché.          **Source de données :** `identity_establishment` table     **Authentification :** Requiert en-tête `X-User`     **Réponse :** Liste des UUIDs d\'établissements          **Erreurs :**     - `403` : Aucun rattachement à un établissement     - `404` : Utilisateur non trouvé
         * @summary Liste des établissements de l\'utilisateur
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserEstablishmentsApiV1IdentityMeEstablishmentsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/identity/me/establishments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère les rôles de l\'utilisateur dans un établissement spécifique.          **Source de données :** `identity_establishment_role` avec jointures sur les catalogues     **Authentification :** Requiert en-têtes `X-User`     **Paramètres :** `etab` (UUID de l\'établissement)     **Réponse :** Liste des rôles avec détails (principal, effectif, cycles, matières)          **Erreurs :**     - `403` : Utilisateur non rattaché à l\'établissement ou aucun rôle     - `404` : Utilisateur non trouvé
         * @summary Rôles de l\'utilisateur dans un établissement
         * @param {string} etab UUID de l\&#39;établissement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRolesApiV1IdentityMeRolesGet: async (etab: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'etab' is not null or undefined
            assertParamExists('getUserRolesApiV1IdentityMeRolesGet', 'etab', etab)
            const localVarPath = `/api/v1/identity/me/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (etab !== undefined) {
                localVarQueryParameter['etab'] = etab;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Valide la sélection de contexte (établissement + rôle) par l\'utilisateur.          **Validation :** Vérifie que l\'utilisateur a ce rôle dans cet établissement     **Authentification :** Requiert en-tête `X-User`     **Action :** auth-service s\'occupe de l\'injection des en-têtes après validation          **Erreurs :**     - `403` : Sélection non autorisée (rôle non valide pour l\'établissement)     - `404` : Utilisateur non trouvé
         * @summary Validation de la sélection de contexte
         * @param {ContextSelectRequest} contextSelectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        selectContextApiV1IdentityMeContextSelectPost: async (contextSelectRequest: ContextSelectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contextSelectRequest' is not null or undefined
            assertParamExists('selectContextApiV1IdentityMeContextSelectPost', 'contextSelectRequest', contextSelectRequest)
            const localVarPath = `/api/v1/identity/me/context/select`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contextSelectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeContexteUtilisateurApi - functional programming interface
 * @export
 */
export const MeContexteUtilisateurApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeContexteUtilisateurApiAxiosParamCreator(configuration)
    return {
        /**
         * Récupère la liste des établissements auxquels l\'utilisateur est rattaché.          **Source de données :** `identity_establishment` table     **Authentification :** Requiert en-tête `X-User`     **Réponse :** Liste des UUIDs d\'établissements          **Erreurs :**     - `403` : Aucun rattachement à un établissement     - `404` : Utilisateur non trouvé
         * @summary Liste des établissements de l\'utilisateur
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserEstablishmentsApiV1IdentityMeEstablishmentsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StandardListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserEstablishmentsApiV1IdentityMeEstablishmentsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeContexteUtilisateurApi.getUserEstablishmentsApiV1IdentityMeEstablishmentsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Récupère les rôles de l\'utilisateur dans un établissement spécifique.          **Source de données :** `identity_establishment_role` avec jointures sur les catalogues     **Authentification :** Requiert en-têtes `X-User`     **Paramètres :** `etab` (UUID de l\'établissement)     **Réponse :** Liste des rôles avec détails (principal, effectif, cycles, matières)          **Erreurs :**     - `403` : Utilisateur non rattaché à l\'établissement ou aucun rôle     - `404` : Utilisateur non trouvé
         * @summary Rôles de l\'utilisateur dans un établissement
         * @param {string} etab UUID de l\&#39;établissement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRolesApiV1IdentityMeRolesGet(etab: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StandardListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRolesApiV1IdentityMeRolesGet(etab, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeContexteUtilisateurApi.getUserRolesApiV1IdentityMeRolesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Valide la sélection de contexte (établissement + rôle) par l\'utilisateur.          **Validation :** Vérifie que l\'utilisateur a ce rôle dans cet établissement     **Authentification :** Requiert en-tête `X-User`     **Action :** auth-service s\'occupe de l\'injection des en-têtes après validation          **Erreurs :**     - `403` : Sélection non autorisée (rôle non valide pour l\'établissement)     - `404` : Utilisateur non trouvé
         * @summary Validation de la sélection de contexte
         * @param {ContextSelectRequest} contextSelectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async selectContextApiV1IdentityMeContextSelectPost(contextSelectRequest: ContextSelectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextSelectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.selectContextApiV1IdentityMeContextSelectPost(contextSelectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeContexteUtilisateurApi.selectContextApiV1IdentityMeContextSelectPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MeContexteUtilisateurApi - factory interface
 * @export
 */
export const MeContexteUtilisateurApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeContexteUtilisateurApiFp(configuration)
    return {
        /**
         * Récupère la liste des établissements auxquels l\'utilisateur est rattaché.          **Source de données :** `identity_establishment` table     **Authentification :** Requiert en-tête `X-User`     **Réponse :** Liste des UUIDs d\'établissements          **Erreurs :**     - `403` : Aucun rattachement à un établissement     - `404` : Utilisateur non trouvé
         * @summary Liste des établissements de l\'utilisateur
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserEstablishmentsApiV1IdentityMeEstablishmentsGet(options?: RawAxiosRequestConfig): AxiosPromise<StandardListResponse> {
            return localVarFp.getUserEstablishmentsApiV1IdentityMeEstablishmentsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère les rôles de l\'utilisateur dans un établissement spécifique.          **Source de données :** `identity_establishment_role` avec jointures sur les catalogues     **Authentification :** Requiert en-têtes `X-User`     **Paramètres :** `etab` (UUID de l\'établissement)     **Réponse :** Liste des rôles avec détails (principal, effectif, cycles, matières)          **Erreurs :**     - `403` : Utilisateur non rattaché à l\'établissement ou aucun rôle     - `404` : Utilisateur non trouvé
         * @summary Rôles de l\'utilisateur dans un établissement
         * @param {string} etab UUID de l\&#39;établissement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRolesApiV1IdentityMeRolesGet(etab: string, options?: RawAxiosRequestConfig): AxiosPromise<StandardListResponse> {
            return localVarFp.getUserRolesApiV1IdentityMeRolesGet(etab, options).then((request) => request(axios, basePath));
        },
        /**
         * Valide la sélection de contexte (établissement + rôle) par l\'utilisateur.          **Validation :** Vérifie que l\'utilisateur a ce rôle dans cet établissement     **Authentification :** Requiert en-tête `X-User`     **Action :** auth-service s\'occupe de l\'injection des en-têtes après validation          **Erreurs :**     - `403` : Sélection non autorisée (rôle non valide pour l\'établissement)     - `404` : Utilisateur non trouvé
         * @summary Validation de la sélection de contexte
         * @param {ContextSelectRequest} contextSelectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        selectContextApiV1IdentityMeContextSelectPost(contextSelectRequest: ContextSelectRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContextSelectResponse> {
            return localVarFp.selectContextApiV1IdentityMeContextSelectPost(contextSelectRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MeContexteUtilisateurApi - object-oriented interface
 * @export
 * @class MeContexteUtilisateurApi
 * @extends {BaseAPI}
 */
export class MeContexteUtilisateurApi extends BaseAPI {
    /**
     * Récupère la liste des établissements auxquels l\'utilisateur est rattaché.          **Source de données :** `identity_establishment` table     **Authentification :** Requiert en-tête `X-User`     **Réponse :** Liste des UUIDs d\'établissements          **Erreurs :**     - `403` : Aucun rattachement à un établissement     - `404` : Utilisateur non trouvé
     * @summary Liste des établissements de l\'utilisateur
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeContexteUtilisateurApi
     */
    public getUserEstablishmentsApiV1IdentityMeEstablishmentsGet(options?: RawAxiosRequestConfig) {
        return MeContexteUtilisateurApiFp(this.configuration).getUserEstablishmentsApiV1IdentityMeEstablishmentsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère les rôles de l\'utilisateur dans un établissement spécifique.          **Source de données :** `identity_establishment_role` avec jointures sur les catalogues     **Authentification :** Requiert en-têtes `X-User`     **Paramètres :** `etab` (UUID de l\'établissement)     **Réponse :** Liste des rôles avec détails (principal, effectif, cycles, matières)          **Erreurs :**     - `403` : Utilisateur non rattaché à l\'établissement ou aucun rôle     - `404` : Utilisateur non trouvé
     * @summary Rôles de l\'utilisateur dans un établissement
     * @param {string} etab UUID de l\&#39;établissement
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeContexteUtilisateurApi
     */
    public getUserRolesApiV1IdentityMeRolesGet(etab: string, options?: RawAxiosRequestConfig) {
        return MeContexteUtilisateurApiFp(this.configuration).getUserRolesApiV1IdentityMeRolesGet(etab, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Valide la sélection de contexte (établissement + rôle) par l\'utilisateur.          **Validation :** Vérifie que l\'utilisateur a ce rôle dans cet établissement     **Authentification :** Requiert en-tête `X-User`     **Action :** auth-service s\'occupe de l\'injection des en-têtes après validation          **Erreurs :**     - `403` : Sélection non autorisée (rôle non valide pour l\'établissement)     - `404` : Utilisateur non trouvé
     * @summary Validation de la sélection de contexte
     * @param {ContextSelectRequest} contextSelectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeContexteUtilisateurApi
     */
    public selectContextApiV1IdentityMeContextSelectPost(contextSelectRequest: ContextSelectRequest, options?: RawAxiosRequestConfig) {
        return MeContexteUtilisateurApiFp(this.configuration).selectContextApiV1IdentityMeContextSelectPost(contextSelectRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



