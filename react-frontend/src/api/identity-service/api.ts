/* tslint:disable */
/* eslint-disable */
/**
 * identity-service
 * Service de gestion des identités - Bulk Import et Traçabilité
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Schéma pour lire un batch d\'identités.
 * @export
 * @interface BatchRead
 */
export interface BatchRead {
    /**
     * ID du batch
     * @type {string}
     * @memberof BatchRead
     */
    'id': string;
    /**
     * ID de l\'établissement
     * @type {string}
     * @memberof BatchRead
     */
    'establishment_id': string;
    /**
     * ID de l\'uploader
     * @type {string}
     * @memberof BatchRead
     */
    'uploaded_by': string;
    /**
     * URL du fichier source
     * @type {string}
     * @memberof BatchRead
     */
    'source_file_url': string;
    /**
     * Date de création
     * @type {string}
     * @memberof BatchRead
     */
    'created_at': string;
}
/**
 * Schéma pour la réponse de bulk import.
 * @export
 * @interface BulkImportResponse
 */
export interface BulkImportResponse {
    /**
     * ID du batch créé
     * @type {string}
     * @memberof BulkImportResponse
     */
    'batch_id': string;
    /**
     * Statut de l\'import
     * @type {string}
     * @memberof BulkImportResponse
     */
    'status': string;
    /**
     * Message d\'information
     * @type {string}
     * @memberof BulkImportResponse
     */
    'message': string;
    /**
     * Nombre total d\'éléments traités
     * @type {number}
     * @memberof BulkImportResponse
     */
    'total_items': number;
    /**
     * Nombre d\'éléments créés
     * @type {number}
     * @memberof BulkImportResponse
     */
    'new_count': number;
    /**
     * Nombre d\'éléments mis à jour
     * @type {number}
     * @memberof BulkImportResponse
     */
    'updated_count': number;
    /**
     * Nombre d\'éléments ignorés
     * @type {number}
     * @memberof BulkImportResponse
     */
    'skipped_count': number;
    /**
     * Nombre d\'éléments invalides
     * @type {number}
     * @memberof BulkImportResponse
     */
    'invalid_count': number;
}
/**
 * Schéma pour la création d\'un lien avec un établissement.
 * @export
 * @interface EstablishmentLinkCreate
 */
export interface EstablishmentLinkCreate {
    /**
     * ID de l\'établissement
     * @type {string}
     * @memberof EstablishmentLinkCreate
     */
    'establishment_id': string;
    /**
     * Rôle dans l\'établissement
     * @type {EstablishmentRole}
     * @memberof EstablishmentLinkCreate
     */
    'role': EstablishmentRole;
}


/**
 * Énumération des rôles possibles dans un établissement.
 * @export
 * @enum {string}
 */

export const EstablishmentRole = {
    Student: 'student',
    Parent: 'parent',
    Teacher: 'teacher',
    AdminStaff: 'admin_staff'
} as const;

export type EstablishmentRole = typeof EstablishmentRole[keyof typeof EstablishmentRole];


/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * Schéma pour la création d\'une identité.
 * @export
 * @interface IdentityCreate
 */
export interface IdentityCreate {
    /**
     * Prénom
     * @type {string}
     * @memberof IdentityCreate
     */
    'firstname': string;
    /**
     * Nom de famille
     * @type {string}
     * @memberof IdentityCreate
     */
    'lastname': string;
    /**
     * 
     * @type {string}
     * @memberof IdentityCreate
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IdentityCreate
     */
    'phone'?: string | null;
    /**
     * Statut de l\'identité
     * @type {IdentityStatus}
     * @memberof IdentityCreate
     */
    'status'?: IdentityStatus;
    /**
     * 
     * @type {string}
     * @memberof IdentityCreate
     */
    'external_id'?: string | null;
}


/**
 * Schéma pour la liste des identités.
 * @export
 * @interface IdentityListResponse
 */
export interface IdentityListResponse {
    /**
     * Liste des identités
     * @type {Array<IdentityResponse>}
     * @memberof IdentityListResponse
     */
    'items': Array<IdentityResponse>;
    /**
     * Nombre total d\'identités
     * @type {number}
     * @memberof IdentityListResponse
     */
    'total': number;
    /**
     * Page actuelle
     * @type {number}
     * @memberof IdentityListResponse
     */
    'page': number;
    /**
     * Taille de la page
     * @type {number}
     * @memberof IdentityListResponse
     */
    'size': number;
    /**
     * Nombre total de pages
     * @type {number}
     * @memberof IdentityListResponse
     */
    'pages': number;
}
/**
 * Schéma pour la réponse d\'une identité.
 * @export
 * @interface IdentityResponse
 */
export interface IdentityResponse {
    /**
     * Prénom
     * @type {string}
     * @memberof IdentityResponse
     */
    'firstname': string;
    /**
     * Nom de famille
     * @type {string}
     * @memberof IdentityResponse
     */
    'lastname': string;
    /**
     * 
     * @type {string}
     * @memberof IdentityResponse
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IdentityResponse
     */
    'phone'?: string | null;
    /**
     * Statut de l\'identité
     * @type {IdentityStatus}
     * @memberof IdentityResponse
     */
    'status'?: IdentityStatus;
    /**
     * ID unique de l\'identité
     * @type {string}
     * @memberof IdentityResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof IdentityResponse
     */
    'external_id'?: string | null;
    /**
     * Date de création
     * @type {string}
     * @memberof IdentityResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof IdentityResponse
     */
    'updated_at'?: string | null;
}


/**
 * Énumération des statuts possibles pour une identité.
 * @export
 * @enum {string}
 */

export const IdentityStatus = {
    Active: 'ACTIVE',
    Archived: 'ARCHIVED',
    Transferred: 'TRANSFERRED'
} as const;

export type IdentityStatus = typeof IdentityStatus[keyof typeof IdentityStatus];


/**
 * Schéma pour la modification d\'une identité.
 * @export
 * @interface IdentityUpdate
 */
export interface IdentityUpdate {
    /**
     * 
     * @type {string}
     * @memberof IdentityUpdate
     */
    'firstname'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IdentityUpdate
     */
    'lastname'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IdentityUpdate
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IdentityUpdate
     */
    'phone'?: string | null;
    /**
     * 
     * @type {IdentityStatus}
     * @memberof IdentityUpdate
     */
    'status'?: IdentityStatus | null;
}


/**
 * Schéma de réponse pour un établissement d\'utilisateur.
 * @export
 * @interface UserEstablishmentResponse
 */
export interface UserEstablishmentResponse {
    /**
     * ID de l\'établissement
     * @type {string}
     * @memberof UserEstablishmentResponse
     */
    'establishment_id': string;
    /**
     * Rôles de l\'utilisateur dans cet établissement
     * @type {Array<EstablishmentRole>}
     * @memberof UserEstablishmentResponse
     */
    'roles': Array<EstablishmentRole>;
}
/**
 * Schéma de réponse pour la liste des établissements d\'un utilisateur.
 * @export
 * @interface UserEstablishmentsResponse
 */
export interface UserEstablishmentsResponse {
    /**
     * Liste des établissements de l\'utilisateur
     * @type {Array<UserEstablishmentResponse>}
     * @memberof UserEstablishmentsResponse
     */
    'establishments': Array<UserEstablishmentResponse>;
    /**
     * Nombre total d\'établissements
     * @type {number}
     * @memberof UserEstablishmentsResponse
     */
    'total': number;
}
/**
 * Schéma de réponse pour les rôles d\'un utilisateur dans un établissement.
 * @export
 * @interface UserRolesResponse
 */
export interface UserRolesResponse {
    /**
     * ID de l\'établissement
     * @type {string}
     * @memberof UserRolesResponse
     */
    'establishment_id': string;
    /**
     * Rôles de l\'utilisateur dans cet établissement
     * @type {Array<EstablishmentRole>}
     * @memberof UserRolesResponse
     */
    'roles': Array<EstablishmentRole>;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<ValidationErrorLocInner>}
     * @memberof ValidationError
     */
    'loc': Array<ValidationErrorLocInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {
}

/**
 * BatchesApi - axios parameter creator
 * @export
 */
export const BatchesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Marquer un batch comme COMMITTED (optionnel).  Args:     batch_id: ID du batch     identity_service: Service d\'identité     current_user: Utilisateur authentifié  Returns:     dict: Message de confirmation  Raises:     404: Batch non trouvé     400: Erreur lors du commit
         * @summary Commit Batch
         * @param {string} batchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitBatchApiV1IdentityBatchesBatchIdCommitPost: async (batchId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('commitBatchApiV1IdentityBatchesBatchIdCommitPost', 'batchId', batchId)
            const localVarPath = `/api/v1/identity/batches/{batch_id}/commit`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupérer un batch par son ID.  Args:     batch_id: ID du batch     batch_service: Service de gestion des batches     current_user: Utilisateur authentifié  Returns:     BatchRead: Détails du batch  Raises:     404: Batch non trouvé
         * @summary Get Batch
         * @param {string} batchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchApiV1IdentityBatchesBatchIdGet: async (batchId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('getBatchApiV1IdentityBatchesBatchIdGet', 'batchId', batchId)
            const localVarPath = `/api/v1/identity/batches/{batch_id}`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lister les items d\'un batch avec pagination et filtres.  Args:     batch_id: ID du batch     item_status: Statut des items pour filtrer (NEW, UPDATED, SKIPPED, INVALID)     domain: Domaine des items pour filtrer (student, parent, teacher, admin_staff)     pagination: Paramètres de pagination et tri     identity_service: Service d\'identité     current_user: Utilisateur authentifié  Returns:     dict: Liste paginée des items du batch  Raises:     404: Batch non trouvé
         * @summary Get Batch Items
         * @param {string} batchId 
         * @param {string | null} [itemStatus] 
         * @param {string | null} [domain] 
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de page
         * @param {string | null} [orderBy] Colonne de tri
         * @param {string} [orderDir] Sens de tri (asc/desc)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchItemsApiV1IdentityBatchesBatchIdItemsGet: async (batchId: string, itemStatus?: string | null, domain?: string | null, page?: number, size?: number, orderBy?: string | null, orderDir?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('getBatchItemsApiV1IdentityBatchesBatchIdItemsGet', 'batchId', batchId)
            const localVarPath = `/api/v1/identity/batches/{batch_id}/items`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (itemStatus !== undefined) {
                localVarQueryParameter['item_status'] = itemStatus;
            }

            if (domain !== undefined) {
                localVarQueryParameter['domain'] = domain;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderDir !== undefined) {
                localVarQueryParameter['order_dir'] = orderDir;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lister les batches d\'identités avec pagination et filtres.  Args:     establishment_id: ID de l\'établissement pour filtrer     uploaded_by: ID de l\'uploader pour filtrer     pagination: Paramètres de pagination et tri     batch_service: Service de gestion des batches     current_user: Utilisateur authentifié  Returns:     dict: Liste paginée des batches
         * @summary List Batches
         * @param {string | null} [establishmentId] 
         * @param {string | null} [uploadedBy] 
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de page
         * @param {string | null} [orderBy] Colonne de tri
         * @param {string} [orderDir] Sens de tri (asc/desc)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchesApiV1IdentityBatchesGet: async (establishmentId?: string | null, uploadedBy?: string | null, page?: number, size?: number, orderBy?: string | null, orderDir?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/identity/batches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (establishmentId !== undefined) {
                localVarQueryParameter['establishment_id'] = establishmentId;
            }

            if (uploadedBy !== undefined) {
                localVarQueryParameter['uploaded_by'] = uploadedBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderDir !== undefined) {
                localVarQueryParameter['order_dir'] = orderDir;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BatchesApi - functional programming interface
 * @export
 */
export const BatchesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BatchesApiAxiosParamCreator(configuration)
    return {
        /**
         * Marquer un batch comme COMMITTED (optionnel).  Args:     batch_id: ID du batch     identity_service: Service d\'identité     current_user: Utilisateur authentifié  Returns:     dict: Message de confirmation  Raises:     404: Batch non trouvé     400: Erreur lors du commit
         * @summary Commit Batch
         * @param {string} batchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commitBatchApiV1IdentityBatchesBatchIdCommitPost(batchId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commitBatchApiV1IdentityBatchesBatchIdCommitPost(batchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchesApi.commitBatchApiV1IdentityBatchesBatchIdCommitPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Récupérer un batch par son ID.  Args:     batch_id: ID du batch     batch_service: Service de gestion des batches     current_user: Utilisateur authentifié  Returns:     BatchRead: Détails du batch  Raises:     404: Batch non trouvé
         * @summary Get Batch
         * @param {string} batchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBatchApiV1IdentityBatchesBatchIdGet(batchId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBatchApiV1IdentityBatchesBatchIdGet(batchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchesApi.getBatchApiV1IdentityBatchesBatchIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lister les items d\'un batch avec pagination et filtres.  Args:     batch_id: ID du batch     item_status: Statut des items pour filtrer (NEW, UPDATED, SKIPPED, INVALID)     domain: Domaine des items pour filtrer (student, parent, teacher, admin_staff)     pagination: Paramètres de pagination et tri     identity_service: Service d\'identité     current_user: Utilisateur authentifié  Returns:     dict: Liste paginée des items du batch  Raises:     404: Batch non trouvé
         * @summary Get Batch Items
         * @param {string} batchId 
         * @param {string | null} [itemStatus] 
         * @param {string | null} [domain] 
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de page
         * @param {string | null} [orderBy] Colonne de tri
         * @param {string} [orderDir] Sens de tri (asc/desc)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBatchItemsApiV1IdentityBatchesBatchIdItemsGet(batchId: string, itemStatus?: string | null, domain?: string | null, page?: number, size?: number, orderBy?: string | null, orderDir?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBatchItemsApiV1IdentityBatchesBatchIdItemsGet(batchId, itemStatus, domain, page, size, orderBy, orderDir, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchesApi.getBatchItemsApiV1IdentityBatchesBatchIdItemsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lister les batches d\'identités avec pagination et filtres.  Args:     establishment_id: ID de l\'établissement pour filtrer     uploaded_by: ID de l\'uploader pour filtrer     pagination: Paramètres de pagination et tri     batch_service: Service de gestion des batches     current_user: Utilisateur authentifié  Returns:     dict: Liste paginée des batches
         * @summary List Batches
         * @param {string | null} [establishmentId] 
         * @param {string | null} [uploadedBy] 
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de page
         * @param {string | null} [orderBy] Colonne de tri
         * @param {string} [orderDir] Sens de tri (asc/desc)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBatchesApiV1IdentityBatchesGet(establishmentId?: string | null, uploadedBy?: string | null, page?: number, size?: number, orderBy?: string | null, orderDir?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBatchesApiV1IdentityBatchesGet(establishmentId, uploadedBy, page, size, orderBy, orderDir, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchesApi.listBatchesApiV1IdentityBatchesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BatchesApi - factory interface
 * @export
 */
export const BatchesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BatchesApiFp(configuration)
    return {
        /**
         * Marquer un batch comme COMMITTED (optionnel).  Args:     batch_id: ID du batch     identity_service: Service d\'identité     current_user: Utilisateur authentifié  Returns:     dict: Message de confirmation  Raises:     404: Batch non trouvé     400: Erreur lors du commit
         * @summary Commit Batch
         * @param {string} batchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitBatchApiV1IdentityBatchesBatchIdCommitPost(batchId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.commitBatchApiV1IdentityBatchesBatchIdCommitPost(batchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupérer un batch par son ID.  Args:     batch_id: ID du batch     batch_service: Service de gestion des batches     current_user: Utilisateur authentifié  Returns:     BatchRead: Détails du batch  Raises:     404: Batch non trouvé
         * @summary Get Batch
         * @param {string} batchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchApiV1IdentityBatchesBatchIdGet(batchId: string, options?: RawAxiosRequestConfig): AxiosPromise<BatchRead> {
            return localVarFp.getBatchApiV1IdentityBatchesBatchIdGet(batchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lister les items d\'un batch avec pagination et filtres.  Args:     batch_id: ID du batch     item_status: Statut des items pour filtrer (NEW, UPDATED, SKIPPED, INVALID)     domain: Domaine des items pour filtrer (student, parent, teacher, admin_staff)     pagination: Paramètres de pagination et tri     identity_service: Service d\'identité     current_user: Utilisateur authentifié  Returns:     dict: Liste paginée des items du batch  Raises:     404: Batch non trouvé
         * @summary Get Batch Items
         * @param {string} batchId 
         * @param {string | null} [itemStatus] 
         * @param {string | null} [domain] 
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de page
         * @param {string | null} [orderBy] Colonne de tri
         * @param {string} [orderDir] Sens de tri (asc/desc)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchItemsApiV1IdentityBatchesBatchIdItemsGet(batchId: string, itemStatus?: string | null, domain?: string | null, page?: number, size?: number, orderBy?: string | null, orderDir?: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getBatchItemsApiV1IdentityBatchesBatchIdItemsGet(batchId, itemStatus, domain, page, size, orderBy, orderDir, options).then((request) => request(axios, basePath));
        },
        /**
         * Lister les batches d\'identités avec pagination et filtres.  Args:     establishment_id: ID de l\'établissement pour filtrer     uploaded_by: ID de l\'uploader pour filtrer     pagination: Paramètres de pagination et tri     batch_service: Service de gestion des batches     current_user: Utilisateur authentifié  Returns:     dict: Liste paginée des batches
         * @summary List Batches
         * @param {string | null} [establishmentId] 
         * @param {string | null} [uploadedBy] 
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de page
         * @param {string | null} [orderBy] Colonne de tri
         * @param {string} [orderDir] Sens de tri (asc/desc)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchesApiV1IdentityBatchesGet(establishmentId?: string | null, uploadedBy?: string | null, page?: number, size?: number, orderBy?: string | null, orderDir?: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.listBatchesApiV1IdentityBatchesGet(establishmentId, uploadedBy, page, size, orderBy, orderDir, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BatchesApi - object-oriented interface
 * @export
 * @class BatchesApi
 * @extends {BaseAPI}
 */
export class BatchesApi extends BaseAPI {
    /**
     * Marquer un batch comme COMMITTED (optionnel).  Args:     batch_id: ID du batch     identity_service: Service d\'identité     current_user: Utilisateur authentifié  Returns:     dict: Message de confirmation  Raises:     404: Batch non trouvé     400: Erreur lors du commit
     * @summary Commit Batch
     * @param {string} batchId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public commitBatchApiV1IdentityBatchesBatchIdCommitPost(batchId: string, options?: RawAxiosRequestConfig) {
        return BatchesApiFp(this.configuration).commitBatchApiV1IdentityBatchesBatchIdCommitPost(batchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupérer un batch par son ID.  Args:     batch_id: ID du batch     batch_service: Service de gestion des batches     current_user: Utilisateur authentifié  Returns:     BatchRead: Détails du batch  Raises:     404: Batch non trouvé
     * @summary Get Batch
     * @param {string} batchId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public getBatchApiV1IdentityBatchesBatchIdGet(batchId: string, options?: RawAxiosRequestConfig) {
        return BatchesApiFp(this.configuration).getBatchApiV1IdentityBatchesBatchIdGet(batchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lister les items d\'un batch avec pagination et filtres.  Args:     batch_id: ID du batch     item_status: Statut des items pour filtrer (NEW, UPDATED, SKIPPED, INVALID)     domain: Domaine des items pour filtrer (student, parent, teacher, admin_staff)     pagination: Paramètres de pagination et tri     identity_service: Service d\'identité     current_user: Utilisateur authentifié  Returns:     dict: Liste paginée des items du batch  Raises:     404: Batch non trouvé
     * @summary Get Batch Items
     * @param {string} batchId 
     * @param {string | null} [itemStatus] 
     * @param {string | null} [domain] 
     * @param {number} [page] Numéro de page
     * @param {number} [size] Taille de page
     * @param {string | null} [orderBy] Colonne de tri
     * @param {string} [orderDir] Sens de tri (asc/desc)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public getBatchItemsApiV1IdentityBatchesBatchIdItemsGet(batchId: string, itemStatus?: string | null, domain?: string | null, page?: number, size?: number, orderBy?: string | null, orderDir?: string, options?: RawAxiosRequestConfig) {
        return BatchesApiFp(this.configuration).getBatchItemsApiV1IdentityBatchesBatchIdItemsGet(batchId, itemStatus, domain, page, size, orderBy, orderDir, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lister les batches d\'identités avec pagination et filtres.  Args:     establishment_id: ID de l\'établissement pour filtrer     uploaded_by: ID de l\'uploader pour filtrer     pagination: Paramètres de pagination et tri     batch_service: Service de gestion des batches     current_user: Utilisateur authentifié  Returns:     dict: Liste paginée des batches
     * @summary List Batches
     * @param {string | null} [establishmentId] 
     * @param {string | null} [uploadedBy] 
     * @param {number} [page] Numéro de page
     * @param {number} [size] Taille de page
     * @param {string | null} [orderBy] Colonne de tri
     * @param {string} [orderDir] Sens de tri (asc/desc)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public listBatchesApiV1IdentityBatchesGet(establishmentId?: string | null, uploadedBy?: string | null, page?: number, size?: number, orderBy?: string | null, orderDir?: string, options?: RawAxiosRequestConfig) {
        return BatchesApiFp(this.configuration).listBatchesApiV1IdentityBatchesGet(establishmentId, uploadedBy, page, size, orderBy, orderDir, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Import en masse d\'identités via fichier CSV.  Accepte les formats CSV avec les schémas suivants : - **students.csv** : establishment_id;firstname;lastname;birth_date;gender;level;account_required;email;phone - **parents.csv** : establishment_id;firstname;lastname;email;phone - **teachers.csv** : establishment_id;firstname;lastname;email;phone;subject;hire_date - **admin_staff.csv** : establishment_id;firstname;lastname;email;phone;position;hire_date  Note: L\'external_id (ID Keycloak) sera automatiquement généré lors de la création du compte.  Le domaine est automatiquement détecté à partir des en-têtes du CSV.
         * @summary Bulk Import Identities
         * @param {File} file Fichier CSV à importer
         * @param {string} establishmentId ID de l\\\&#39;établissement
         * @param {string | null} [sourceFileUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkImportIdentitiesApiV1IdentityBulkimportPost: async (file: File, establishmentId: string, sourceFileUrl?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('bulkImportIdentitiesApiV1IdentityBulkimportPost', 'file', file)
            // verify required parameter 'establishmentId' is not null or undefined
            assertParamExists('bulkImportIdentitiesApiV1IdentityBulkimportPost', 'establishmentId', establishmentId)
            const localVarPath = `/api/v1/identity/bulkimport`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (establishmentId !== undefined) { 
                localVarFormParams.append('establishment_id', establishmentId as any);
            }
    
            if (sourceFileUrl !== undefined) { 
                localVarFormParams.append('source_file_url', sourceFileUrl as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Annule un batch d\'import en cours.  Args:     batch_id: ID du batch
         * @summary Cancel Bulk Import
         * @param {string} batchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelBulkImportApiV1IdentityBulkimportCancelBatchIdPost: async (batchId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('cancelBulkImportApiV1IdentityBulkimportCancelBatchIdPost', 'batchId', batchId)
            const localVarPath = `/api/v1/identity/bulkimport/cancel/{batch_id}`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Crée une nouvelle identité.  Args:     identity_data: Données de l\'identité à créer     request: Requête HTTP     identity_crud_service: Service CRUD des identités      Returns:     IdentityResponse: Identité créée
         * @summary Create Identity
         * @param {IdentityCreate} identityCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIdentityApiV1IdentityIdentitiesPost: async (identityCreate: IdentityCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityCreate' is not null or undefined
            assertParamExists('createIdentityApiV1IdentityIdentitiesPost', 'identityCreate', identityCreate)
            const localVarPath = `/api/v1/identity/identities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identityCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Supprime une identité.  Args:     identity_id: ID de l\'identité à supprimer     request: Requête HTTP     identity_crud_service: Service CRUD des identités      Returns:     Dict: Message de confirmation
         * @summary Delete Identity
         * @param {string} identityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentityApiV1IdentityIdentitiesIdentityIdDelete: async (identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('deleteIdentityApiV1IdentityIdentitiesIdentityIdDelete', 'identityId', identityId)
            const localVarPath = `/api/v1/identity/identities/{identity_id}`
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère l\'historique d\'audit des opérations de bulk import.  Args:     user_id: Filtrer par utilisateur     establishment_id: Filtrer par établissement     batch_id: Filtrer par batch     limit: Limite du nombre de résultats
         * @summary Get Audit History
         * @param {string | null} [userId] 
         * @param {string | null} [establishmentId] 
         * @param {string | null} [batchId] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditHistoryApiV1IdentityBulkimportAuditGet: async (userId?: string | null, establishmentId?: string | null, batchId?: string | null, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/identity/bulkimport/audit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (establishmentId !== undefined) {
                localVarQueryParameter['establishment_id'] = establishmentId;
            }

            if (batchId !== undefined) {
                localVarQueryParameter['batch_id'] = batchId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère la progression d\'un batch d\'import.  Args:     batch_id: ID du batch
         * @summary Get Bulk Import Progress
         * @param {string} batchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBulkImportProgressApiV1IdentityBulkimportProgressBatchIdGet: async (batchId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('getBulkImportProgressApiV1IdentityBulkimportProgressBatchIdGet', 'batchId', batchId)
            const localVarPath = `/api/v1/identity/bulkimport/progress/{batch_id}`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère un template CSV pour un domaine donné.  Args:     domain: Domaine (student, parent, teacher, admin_staff)
         * @summary Get Csv Template
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCsvTemplateApiV1IdentityBulkimportTemplateDomainGet: async (domain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('getCsvTemplateApiV1IdentityBulkimportTemplateDomainGet', 'domain', domain)
            const localVarPath = `/api/v1/identity/bulkimport/template/{domain}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère une identité par son ID.  Args:     identity_id: ID de l\'identité     request: Requête HTTP     identity_crud_service: Service CRUD des identités      Returns:     IdentityResponse: Identité trouvée
         * @summary Get Identity
         * @param {string} identityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityApiV1IdentityIdentitiesIdentityIdGet: async (identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('getIdentityApiV1IdentityIdentitiesIdentityIdGet', 'identityId', identityId)
            const localVarPath = `/api/v1/identity/identities/{identity_id}`
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère les statistiques des connexions SSE.  Returns:     Dict: Statistiques des connexions
         * @summary Get Sse Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSseStatsApiV1IdentityBulkimportSseStatsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/identity/bulkimport/sse/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère la liste des établissements de l\'utilisateur connecté.  Source: identity_establishment(identity_id, establishment_id) Retourne 403 si aucun rattachement.  Args:     current_user: Utilisateur connecté     identity_crud_service: Service CRUD des identités      Returns:     UserEstablishmentsResponse: Liste des établissements avec leurs rôles
         * @summary Get User Establishments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserEstablishmentsApiV1IdentityMeEstablishmentsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/identity/me/establishments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Récupère les rôles de l\'utilisateur dans un établissement spécifique.  Source: identity_establishment.role (ENUM: student|parent|teacher|admin_staff) Retourne 403 si l\'utilisateur n\'est pas rattaché à l\'établissement.  Args:     etab: UUID de l\'établissement     current_user: Utilisateur connecté     identity_crud_service: Service CRUD des identités      Returns:     UserRolesResponse: Rôles de l\'utilisateur dans l\'établissement
         * @summary Get User Roles In Establishment
         * @param {string} etab UUID de l\&#39;établissement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRolesInEstablishmentApiV1IdentityMeRolesGet: async (etab: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'etab' is not null or undefined
            assertParamExists('getUserRolesInEstablishmentApiV1IdentityMeRolesGet', 'etab', etab)
            const localVarPath = `/api/v1/identity/me/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (etab !== undefined) {
                localVarQueryParameter['etab'] = etab;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint de vérification de santé du service.
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheckHealthGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lie une identité à un établissement.  Args:     identity_id: ID de l\'identité     link_data: Données du lien     request: Requête HTTP     identity_crud_service: Service CRUD des identités      Returns:     Dict: Message de confirmation
         * @summary Link Identity To Establishment
         * @param {string} identityId 
         * @param {EstablishmentLinkCreate} establishmentLinkCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkIdentityToEstablishmentApiV1IdentityIdentitiesIdentityIdEstablishmentsPost: async (identityId: string, establishmentLinkCreate: EstablishmentLinkCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('linkIdentityToEstablishmentApiV1IdentityIdentitiesIdentityIdEstablishmentsPost', 'identityId', identityId)
            // verify required parameter 'establishmentLinkCreate' is not null or undefined
            assertParamExists('linkIdentityToEstablishmentApiV1IdentityIdentitiesIdentityIdEstablishmentsPost', 'establishmentLinkCreate', establishmentLinkCreate)
            const localVarPath = `/api/v1/identity/identities/{identity_id}/establishments`
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(establishmentLinkCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Liste les identités avec pagination et filtres.  Args:     page: Numéro de page     size: Taille de la page     search: Terme de recherche global     sort_by: Champ de tri     sort_order: Ordre de tri     firstname: Filtre par prénom     lastname: Filtre par nom     email: Filtre par email     status: Filtre par statut     establishment_id: Filtre par établissement     role: Filtre par rôle     request: Requête HTTP     identity_crud_service: Service CRUD des identités      Returns:     IdentityListResponse: Liste paginée des identités
         * @summary List Identities
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de la page
         * @param {string | null} [search] Terme de recherche global
         * @param {string | null} [sortBy] Champ de tri
         * @param {string | null} [sortOrder] Ordre de tri
         * @param {string | null} [firstname] Filtrer par prénom
         * @param {string | null} [lastname] Filtrer par nom
         * @param {string | null} [email] Filtrer par email
         * @param {string | null} [status] Filtrer par statut
         * @param {string | null} [establishmentId] Filtrer par établissement
         * @param {string | null} [role] Filtrer par rôle
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIdentitiesApiV1IdentityIdentitiesGet: async (page?: number, size?: number, search?: string | null, sortBy?: string | null, sortOrder?: string | null, firstname?: string | null, lastname?: string | null, email?: string | null, status?: string | null, establishmentId?: string | null, role?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/identity/identities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (firstname !== undefined) {
                localVarQueryParameter['firstname'] = firstname;
            }

            if (lastname !== undefined) {
                localVarQueryParameter['lastname'] = lastname;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (establishmentId !== undefined) {
                localVarQueryParameter['establishment_id'] = establishmentId;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint racine pour vérifier que le service fonctionne.
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gestion des requêtes OPTIONS pour CORS.  Args:     batch_id: ID du batch      Returns:     Response: Headers CORS
         * @summary Sse Options
         * @param {string} batchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sseOptionsApiV1IdentityBulkimportStreamBatchIdOptions: async (batchId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('sseOptionsApiV1IdentityBulkimportStreamBatchIdOptions', 'batchId', batchId)
            const localVarPath = `/api/v1/identity/bulkimport/stream/{batch_id}`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stream Server-Sent Events pour la progression d\'un batch.  Args:     batch_id: ID du batch à suivre     timeout: Timeout en secondes (5 minutes par défaut)     request: Requête HTTP     bulk_import_service: Service de bulk import      Returns:     StreamingResponse: Flux SSE de la progression
         * @summary Stream Batch Progress
         * @param {string} batchId 
         * @param {number | null} [timeout] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamBatchProgressApiV1IdentityBulkimportStreamBatchIdGet: async (batchId: string, timeout?: number | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('streamBatchProgressApiV1IdentityBulkimportStreamBatchIdGet', 'batchId', batchId)
            const localVarPath = `/api/v1/identity/bulkimport/stream/{batch_id}`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Supprime le lien entre une identité et un établissement.  Args:     identity_id: ID de l\'identité     establishment_id: ID de l\'établissement     request: Requête HTTP     identity_crud_service: Service CRUD des identités      Returns:     Dict: Message de confirmation
         * @summary Unlink Identity From Establishment
         * @param {string} identityId 
         * @param {string} establishmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkIdentityFromEstablishmentApiV1IdentityIdentitiesIdentityIdEstablishmentsEstablishmentIdDelete: async (identityId: string, establishmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('unlinkIdentityFromEstablishmentApiV1IdentityIdentitiesIdentityIdEstablishmentsEstablishmentIdDelete', 'identityId', identityId)
            // verify required parameter 'establishmentId' is not null or undefined
            assertParamExists('unlinkIdentityFromEstablishmentApiV1IdentityIdentitiesIdentityIdEstablishmentsEstablishmentIdDelete', 'establishmentId', establishmentId)
            const localVarPath = `/api/v1/identity/identities/{identity_id}/establishments/{establishment_id}`
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)))
                .replace(`{${"establishment_id"}}`, encodeURIComponent(String(establishmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Met à jour une identité.  Args:     identity_id: ID de l\'identité à mettre à jour     identity_data: Nouvelles données     request: Requête HTTP     identity_crud_service: Service CRUD des identités      Returns:     IdentityResponse: Identité mise à jour
         * @summary Update Identity
         * @param {string} identityId 
         * @param {IdentityUpdate} identityUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIdentityApiV1IdentityIdentitiesIdentityIdPut: async (identityId: string, identityUpdate: IdentityUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('updateIdentityApiV1IdentityIdentitiesIdentityIdPut', 'identityId', identityId)
            // verify required parameter 'identityUpdate' is not null or undefined
            assertParamExists('updateIdentityApiV1IdentityIdentitiesIdentityIdPut', 'identityUpdate', identityUpdate)
            const localVarPath = `/api/v1/identity/identities/{identity_id}`
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identityUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Import en masse d\'identités via fichier CSV.  Accepte les formats CSV avec les schémas suivants : - **students.csv** : establishment_id;firstname;lastname;birth_date;gender;level;account_required;email;phone - **parents.csv** : establishment_id;firstname;lastname;email;phone - **teachers.csv** : establishment_id;firstname;lastname;email;phone;subject;hire_date - **admin_staff.csv** : establishment_id;firstname;lastname;email;phone;position;hire_date  Note: L\'external_id (ID Keycloak) sera automatiquement généré lors de la création du compte.  Le domaine est automatiquement détecté à partir des en-têtes du CSV.
         * @summary Bulk Import Identities
         * @param {File} file Fichier CSV à importer
         * @param {string} establishmentId ID de l\\\&#39;établissement
         * @param {string | null} [sourceFileUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkImportIdentitiesApiV1IdentityBulkimportPost(file: File, establishmentId: string, sourceFileUrl?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkImportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkImportIdentitiesApiV1IdentityBulkimportPost(file, establishmentId, sourceFileUrl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.bulkImportIdentitiesApiV1IdentityBulkimportPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Annule un batch d\'import en cours.  Args:     batch_id: ID du batch
         * @summary Cancel Bulk Import
         * @param {string} batchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelBulkImportApiV1IdentityBulkimportCancelBatchIdPost(batchId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelBulkImportApiV1IdentityBulkimportCancelBatchIdPost(batchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.cancelBulkImportApiV1IdentityBulkimportCancelBatchIdPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Crée une nouvelle identité.  Args:     identity_data: Données de l\'identité à créer     request: Requête HTTP     identity_crud_service: Service CRUD des identités      Returns:     IdentityResponse: Identité créée
         * @summary Create Identity
         * @param {IdentityCreate} identityCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createIdentityApiV1IdentityIdentitiesPost(identityCreate: IdentityCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createIdentityApiV1IdentityIdentitiesPost(identityCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createIdentityApiV1IdentityIdentitiesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Supprime une identité.  Args:     identity_id: ID de l\'identité à supprimer     request: Requête HTTP     identity_crud_service: Service CRUD des identités      Returns:     Dict: Message de confirmation
         * @summary Delete Identity
         * @param {string} identityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteIdentityApiV1IdentityIdentitiesIdentityIdDelete(identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteIdentityApiV1IdentityIdentitiesIdentityIdDelete(identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteIdentityApiV1IdentityIdentitiesIdentityIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Récupère l\'historique d\'audit des opérations de bulk import.  Args:     user_id: Filtrer par utilisateur     establishment_id: Filtrer par établissement     batch_id: Filtrer par batch     limit: Limite du nombre de résultats
         * @summary Get Audit History
         * @param {string | null} [userId] 
         * @param {string | null} [establishmentId] 
         * @param {string | null} [batchId] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuditHistoryApiV1IdentityBulkimportAuditGet(userId?: string | null, establishmentId?: string | null, batchId?: string | null, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuditHistoryApiV1IdentityBulkimportAuditGet(userId, establishmentId, batchId, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getAuditHistoryApiV1IdentityBulkimportAuditGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Récupère la progression d\'un batch d\'import.  Args:     batch_id: ID du batch
         * @summary Get Bulk Import Progress
         * @param {string} batchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBulkImportProgressApiV1IdentityBulkimportProgressBatchIdGet(batchId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBulkImportProgressApiV1IdentityBulkimportProgressBatchIdGet(batchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getBulkImportProgressApiV1IdentityBulkimportProgressBatchIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Récupère un template CSV pour un domaine donné.  Args:     domain: Domaine (student, parent, teacher, admin_staff)
         * @summary Get Csv Template
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCsvTemplateApiV1IdentityBulkimportTemplateDomainGet(domain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCsvTemplateApiV1IdentityBulkimportTemplateDomainGet(domain, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getCsvTemplateApiV1IdentityBulkimportTemplateDomainGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Récupère une identité par son ID.  Args:     identity_id: ID de l\'identité     request: Requête HTTP     identity_crud_service: Service CRUD des identités      Returns:     IdentityResponse: Identité trouvée
         * @summary Get Identity
         * @param {string} identityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityApiV1IdentityIdentitiesIdentityIdGet(identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityApiV1IdentityIdentitiesIdentityIdGet(identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getIdentityApiV1IdentityIdentitiesIdentityIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Récupère les statistiques des connexions SSE.  Returns:     Dict: Statistiques des connexions
         * @summary Get Sse Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSseStatsApiV1IdentityBulkimportSseStatsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSseStatsApiV1IdentityBulkimportSseStatsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getSseStatsApiV1IdentityBulkimportSseStatsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Récupère la liste des établissements de l\'utilisateur connecté.  Source: identity_establishment(identity_id, establishment_id) Retourne 403 si aucun rattachement.  Args:     current_user: Utilisateur connecté     identity_crud_service: Service CRUD des identités      Returns:     UserEstablishmentsResponse: Liste des établissements avec leurs rôles
         * @summary Get User Establishments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserEstablishmentsApiV1IdentityMeEstablishmentsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserEstablishmentsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserEstablishmentsApiV1IdentityMeEstablishmentsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getUserEstablishmentsApiV1IdentityMeEstablishmentsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Récupère les rôles de l\'utilisateur dans un établissement spécifique.  Source: identity_establishment.role (ENUM: student|parent|teacher|admin_staff) Retourne 403 si l\'utilisateur n\'est pas rattaché à l\'établissement.  Args:     etab: UUID de l\'établissement     current_user: Utilisateur connecté     identity_crud_service: Service CRUD des identités      Returns:     UserRolesResponse: Rôles de l\'utilisateur dans l\'établissement
         * @summary Get User Roles In Establishment
         * @param {string} etab UUID de l\&#39;établissement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRolesInEstablishmentApiV1IdentityMeRolesGet(etab: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRolesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRolesInEstablishmentApiV1IdentityMeRolesGet(etab, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getUserRolesInEstablishmentApiV1IdentityMeRolesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Endpoint de vérification de santé du service.
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthCheckHealthGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthCheckHealthGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.healthCheckHealthGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lie une identité à un établissement.  Args:     identity_id: ID de l\'identité     link_data: Données du lien     request: Requête HTTP     identity_crud_service: Service CRUD des identités      Returns:     Dict: Message de confirmation
         * @summary Link Identity To Establishment
         * @param {string} identityId 
         * @param {EstablishmentLinkCreate} establishmentLinkCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkIdentityToEstablishmentApiV1IdentityIdentitiesIdentityIdEstablishmentsPost(identityId: string, establishmentLinkCreate: EstablishmentLinkCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.linkIdentityToEstablishmentApiV1IdentityIdentitiesIdentityIdEstablishmentsPost(identityId, establishmentLinkCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.linkIdentityToEstablishmentApiV1IdentityIdentitiesIdentityIdEstablishmentsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Liste les identités avec pagination et filtres.  Args:     page: Numéro de page     size: Taille de la page     search: Terme de recherche global     sort_by: Champ de tri     sort_order: Ordre de tri     firstname: Filtre par prénom     lastname: Filtre par nom     email: Filtre par email     status: Filtre par statut     establishment_id: Filtre par établissement     role: Filtre par rôle     request: Requête HTTP     identity_crud_service: Service CRUD des identités      Returns:     IdentityListResponse: Liste paginée des identités
         * @summary List Identities
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de la page
         * @param {string | null} [search] Terme de recherche global
         * @param {string | null} [sortBy] Champ de tri
         * @param {string | null} [sortOrder] Ordre de tri
         * @param {string | null} [firstname] Filtrer par prénom
         * @param {string | null} [lastname] Filtrer par nom
         * @param {string | null} [email] Filtrer par email
         * @param {string | null} [status] Filtrer par statut
         * @param {string | null} [establishmentId] Filtrer par établissement
         * @param {string | null} [role] Filtrer par rôle
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listIdentitiesApiV1IdentityIdentitiesGet(page?: number, size?: number, search?: string | null, sortBy?: string | null, sortOrder?: string | null, firstname?: string | null, lastname?: string | null, email?: string | null, status?: string | null, establishmentId?: string | null, role?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIdentitiesApiV1IdentityIdentitiesGet(page, size, search, sortBy, sortOrder, firstname, lastname, email, status, establishmentId, role, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listIdentitiesApiV1IdentityIdentitiesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Endpoint racine pour vérifier que le service fonctionne.
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rootGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rootGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.rootGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gestion des requêtes OPTIONS pour CORS.  Args:     batch_id: ID du batch      Returns:     Response: Headers CORS
         * @summary Sse Options
         * @param {string} batchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sseOptionsApiV1IdentityBulkimportStreamBatchIdOptions(batchId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sseOptionsApiV1IdentityBulkimportStreamBatchIdOptions(batchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.sseOptionsApiV1IdentityBulkimportStreamBatchIdOptions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Stream Server-Sent Events pour la progression d\'un batch.  Args:     batch_id: ID du batch à suivre     timeout: Timeout en secondes (5 minutes par défaut)     request: Requête HTTP     bulk_import_service: Service de bulk import      Returns:     StreamingResponse: Flux SSE de la progression
         * @summary Stream Batch Progress
         * @param {string} batchId 
         * @param {number | null} [timeout] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamBatchProgressApiV1IdentityBulkimportStreamBatchIdGet(batchId: string, timeout?: number | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.streamBatchProgressApiV1IdentityBulkimportStreamBatchIdGet(batchId, timeout, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.streamBatchProgressApiV1IdentityBulkimportStreamBatchIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Supprime le lien entre une identité et un établissement.  Args:     identity_id: ID de l\'identité     establishment_id: ID de l\'établissement     request: Requête HTTP     identity_crud_service: Service CRUD des identités      Returns:     Dict: Message de confirmation
         * @summary Unlink Identity From Establishment
         * @param {string} identityId 
         * @param {string} establishmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlinkIdentityFromEstablishmentApiV1IdentityIdentitiesIdentityIdEstablishmentsEstablishmentIdDelete(identityId: string, establishmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlinkIdentityFromEstablishmentApiV1IdentityIdentitiesIdentityIdEstablishmentsEstablishmentIdDelete(identityId, establishmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.unlinkIdentityFromEstablishmentApiV1IdentityIdentitiesIdentityIdEstablishmentsEstablishmentIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Met à jour une identité.  Args:     identity_id: ID de l\'identité à mettre à jour     identity_data: Nouvelles données     request: Requête HTTP     identity_crud_service: Service CRUD des identités      Returns:     IdentityResponse: Identité mise à jour
         * @summary Update Identity
         * @param {string} identityId 
         * @param {IdentityUpdate} identityUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateIdentityApiV1IdentityIdentitiesIdentityIdPut(identityId: string, identityUpdate: IdentityUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateIdentityApiV1IdentityIdentitiesIdentityIdPut(identityId, identityUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateIdentityApiV1IdentityIdentitiesIdentityIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Import en masse d\'identités via fichier CSV.  Accepte les formats CSV avec les schémas suivants : - **students.csv** : establishment_id;firstname;lastname;birth_date;gender;level;account_required;email;phone - **parents.csv** : establishment_id;firstname;lastname;email;phone - **teachers.csv** : establishment_id;firstname;lastname;email;phone;subject;hire_date - **admin_staff.csv** : establishment_id;firstname;lastname;email;phone;position;hire_date  Note: L\'external_id (ID Keycloak) sera automatiquement généré lors de la création du compte.  Le domaine est automatiquement détecté à partir des en-têtes du CSV.
         * @summary Bulk Import Identities
         * @param {File} file Fichier CSV à importer
         * @param {string} establishmentId ID de l\\\&#39;établissement
         * @param {string | null} [sourceFileUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkImportIdentitiesApiV1IdentityBulkimportPost(file: File, establishmentId: string, sourceFileUrl?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<BulkImportResponse> {
            return localVarFp.bulkImportIdentitiesApiV1IdentityBulkimportPost(file, establishmentId, sourceFileUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * Annule un batch d\'import en cours.  Args:     batch_id: ID du batch
         * @summary Cancel Bulk Import
         * @param {string} batchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelBulkImportApiV1IdentityBulkimportCancelBatchIdPost(batchId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.cancelBulkImportApiV1IdentityBulkimportCancelBatchIdPost(batchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Crée une nouvelle identité.  Args:     identity_data: Données de l\'identité à créer     request: Requête HTTP     identity_crud_service: Service CRUD des identités      Returns:     IdentityResponse: Identité créée
         * @summary Create Identity
         * @param {IdentityCreate} identityCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIdentityApiV1IdentityIdentitiesPost(identityCreate: IdentityCreate, options?: RawAxiosRequestConfig): AxiosPromise<IdentityResponse> {
            return localVarFp.createIdentityApiV1IdentityIdentitiesPost(identityCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Supprime une identité.  Args:     identity_id: ID de l\'identité à supprimer     request: Requête HTTP     identity_crud_service: Service CRUD des identités      Returns:     Dict: Message de confirmation
         * @summary Delete Identity
         * @param {string} identityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentityApiV1IdentityIdentitiesIdentityIdDelete(identityId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.deleteIdentityApiV1IdentityIdentitiesIdentityIdDelete(identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère l\'historique d\'audit des opérations de bulk import.  Args:     user_id: Filtrer par utilisateur     establishment_id: Filtrer par établissement     batch_id: Filtrer par batch     limit: Limite du nombre de résultats
         * @summary Get Audit History
         * @param {string | null} [userId] 
         * @param {string | null} [establishmentId] 
         * @param {string | null} [batchId] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditHistoryApiV1IdentityBulkimportAuditGet(userId?: string | null, establishmentId?: string | null, batchId?: string | null, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getAuditHistoryApiV1IdentityBulkimportAuditGet(userId, establishmentId, batchId, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère la progression d\'un batch d\'import.  Args:     batch_id: ID du batch
         * @summary Get Bulk Import Progress
         * @param {string} batchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBulkImportProgressApiV1IdentityBulkimportProgressBatchIdGet(batchId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getBulkImportProgressApiV1IdentityBulkimportProgressBatchIdGet(batchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère un template CSV pour un domaine donné.  Args:     domain: Domaine (student, parent, teacher, admin_staff)
         * @summary Get Csv Template
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCsvTemplateApiV1IdentityBulkimportTemplateDomainGet(domain: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getCsvTemplateApiV1IdentityBulkimportTemplateDomainGet(domain, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère une identité par son ID.  Args:     identity_id: ID de l\'identité     request: Requête HTTP     identity_crud_service: Service CRUD des identités      Returns:     IdentityResponse: Identité trouvée
         * @summary Get Identity
         * @param {string} identityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityApiV1IdentityIdentitiesIdentityIdGet(identityId: string, options?: RawAxiosRequestConfig): AxiosPromise<IdentityResponse> {
            return localVarFp.getIdentityApiV1IdentityIdentitiesIdentityIdGet(identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère les statistiques des connexions SSE.  Returns:     Dict: Statistiques des connexions
         * @summary Get Sse Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSseStatsApiV1IdentityBulkimportSseStatsGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getSseStatsApiV1IdentityBulkimportSseStatsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère la liste des établissements de l\'utilisateur connecté.  Source: identity_establishment(identity_id, establishment_id) Retourne 403 si aucun rattachement.  Args:     current_user: Utilisateur connecté     identity_crud_service: Service CRUD des identités      Returns:     UserEstablishmentsResponse: Liste des établissements avec leurs rôles
         * @summary Get User Establishments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserEstablishmentsApiV1IdentityMeEstablishmentsGet(options?: RawAxiosRequestConfig): AxiosPromise<UserEstablishmentsResponse> {
            return localVarFp.getUserEstablishmentsApiV1IdentityMeEstablishmentsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Récupère les rôles de l\'utilisateur dans un établissement spécifique.  Source: identity_establishment.role (ENUM: student|parent|teacher|admin_staff) Retourne 403 si l\'utilisateur n\'est pas rattaché à l\'établissement.  Args:     etab: UUID de l\'établissement     current_user: Utilisateur connecté     identity_crud_service: Service CRUD des identités      Returns:     UserRolesResponse: Rôles de l\'utilisateur dans l\'établissement
         * @summary Get User Roles In Establishment
         * @param {string} etab UUID de l\&#39;établissement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRolesInEstablishmentApiV1IdentityMeRolesGet(etab: string, options?: RawAxiosRequestConfig): AxiosPromise<UserRolesResponse> {
            return localVarFp.getUserRolesInEstablishmentApiV1IdentityMeRolesGet(etab, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint de vérification de santé du service.
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheckHealthGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.healthCheckHealthGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Lie une identité à un établissement.  Args:     identity_id: ID de l\'identité     link_data: Données du lien     request: Requête HTTP     identity_crud_service: Service CRUD des identités      Returns:     Dict: Message de confirmation
         * @summary Link Identity To Establishment
         * @param {string} identityId 
         * @param {EstablishmentLinkCreate} establishmentLinkCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkIdentityToEstablishmentApiV1IdentityIdentitiesIdentityIdEstablishmentsPost(identityId: string, establishmentLinkCreate: EstablishmentLinkCreate, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.linkIdentityToEstablishmentApiV1IdentityIdentitiesIdentityIdEstablishmentsPost(identityId, establishmentLinkCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Liste les identités avec pagination et filtres.  Args:     page: Numéro de page     size: Taille de la page     search: Terme de recherche global     sort_by: Champ de tri     sort_order: Ordre de tri     firstname: Filtre par prénom     lastname: Filtre par nom     email: Filtre par email     status: Filtre par statut     establishment_id: Filtre par établissement     role: Filtre par rôle     request: Requête HTTP     identity_crud_service: Service CRUD des identités      Returns:     IdentityListResponse: Liste paginée des identités
         * @summary List Identities
         * @param {number} [page] Numéro de page
         * @param {number} [size] Taille de la page
         * @param {string | null} [search] Terme de recherche global
         * @param {string | null} [sortBy] Champ de tri
         * @param {string | null} [sortOrder] Ordre de tri
         * @param {string | null} [firstname] Filtrer par prénom
         * @param {string | null} [lastname] Filtrer par nom
         * @param {string | null} [email] Filtrer par email
         * @param {string | null} [status] Filtrer par statut
         * @param {string | null} [establishmentId] Filtrer par établissement
         * @param {string | null} [role] Filtrer par rôle
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIdentitiesApiV1IdentityIdentitiesGet(page?: number, size?: number, search?: string | null, sortBy?: string | null, sortOrder?: string | null, firstname?: string | null, lastname?: string | null, email?: string | null, status?: string | null, establishmentId?: string | null, role?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<IdentityListResponse> {
            return localVarFp.listIdentitiesApiV1IdentityIdentitiesGet(page, size, search, sortBy, sortOrder, firstname, lastname, email, status, establishmentId, role, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint racine pour vérifier que le service fonctionne.
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.rootGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Gestion des requêtes OPTIONS pour CORS.  Args:     batch_id: ID du batch      Returns:     Response: Headers CORS
         * @summary Sse Options
         * @param {string} batchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sseOptionsApiV1IdentityBulkimportStreamBatchIdOptions(batchId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.sseOptionsApiV1IdentityBulkimportStreamBatchIdOptions(batchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Stream Server-Sent Events pour la progression d\'un batch.  Args:     batch_id: ID du batch à suivre     timeout: Timeout en secondes (5 minutes par défaut)     request: Requête HTTP     bulk_import_service: Service de bulk import      Returns:     StreamingResponse: Flux SSE de la progression
         * @summary Stream Batch Progress
         * @param {string} batchId 
         * @param {number | null} [timeout] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamBatchProgressApiV1IdentityBulkimportStreamBatchIdGet(batchId: string, timeout?: number | null, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.streamBatchProgressApiV1IdentityBulkimportStreamBatchIdGet(batchId, timeout, options).then((request) => request(axios, basePath));
        },
        /**
         * Supprime le lien entre une identité et un établissement.  Args:     identity_id: ID de l\'identité     establishment_id: ID de l\'établissement     request: Requête HTTP     identity_crud_service: Service CRUD des identités      Returns:     Dict: Message de confirmation
         * @summary Unlink Identity From Establishment
         * @param {string} identityId 
         * @param {string} establishmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkIdentityFromEstablishmentApiV1IdentityIdentitiesIdentityIdEstablishmentsEstablishmentIdDelete(identityId: string, establishmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.unlinkIdentityFromEstablishmentApiV1IdentityIdentitiesIdentityIdEstablishmentsEstablishmentIdDelete(identityId, establishmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Met à jour une identité.  Args:     identity_id: ID de l\'identité à mettre à jour     identity_data: Nouvelles données     request: Requête HTTP     identity_crud_service: Service CRUD des identités      Returns:     IdentityResponse: Identité mise à jour
         * @summary Update Identity
         * @param {string} identityId 
         * @param {IdentityUpdate} identityUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIdentityApiV1IdentityIdentitiesIdentityIdPut(identityId: string, identityUpdate: IdentityUpdate, options?: RawAxiosRequestConfig): AxiosPromise<IdentityResponse> {
            return localVarFp.updateIdentityApiV1IdentityIdentitiesIdentityIdPut(identityId, identityUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Import en masse d\'identités via fichier CSV.  Accepte les formats CSV avec les schémas suivants : - **students.csv** : establishment_id;firstname;lastname;birth_date;gender;level;account_required;email;phone - **parents.csv** : establishment_id;firstname;lastname;email;phone - **teachers.csv** : establishment_id;firstname;lastname;email;phone;subject;hire_date - **admin_staff.csv** : establishment_id;firstname;lastname;email;phone;position;hire_date  Note: L\'external_id (ID Keycloak) sera automatiquement généré lors de la création du compte.  Le domaine est automatiquement détecté à partir des en-têtes du CSV.
     * @summary Bulk Import Identities
     * @param {File} file Fichier CSV à importer
     * @param {string} establishmentId ID de l\\\&#39;établissement
     * @param {string | null} [sourceFileUrl] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public bulkImportIdentitiesApiV1IdentityBulkimportPost(file: File, establishmentId: string, sourceFileUrl?: string | null, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).bulkImportIdentitiesApiV1IdentityBulkimportPost(file, establishmentId, sourceFileUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Annule un batch d\'import en cours.  Args:     batch_id: ID du batch
     * @summary Cancel Bulk Import
     * @param {string} batchId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public cancelBulkImportApiV1IdentityBulkimportCancelBatchIdPost(batchId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).cancelBulkImportApiV1IdentityBulkimportCancelBatchIdPost(batchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Crée une nouvelle identité.  Args:     identity_data: Données de l\'identité à créer     request: Requête HTTP     identity_crud_service: Service CRUD des identités      Returns:     IdentityResponse: Identité créée
     * @summary Create Identity
     * @param {IdentityCreate} identityCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createIdentityApiV1IdentityIdentitiesPost(identityCreate: IdentityCreate, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createIdentityApiV1IdentityIdentitiesPost(identityCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Supprime une identité.  Args:     identity_id: ID de l\'identité à supprimer     request: Requête HTTP     identity_crud_service: Service CRUD des identités      Returns:     Dict: Message de confirmation
     * @summary Delete Identity
     * @param {string} identityId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteIdentityApiV1IdentityIdentitiesIdentityIdDelete(identityId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteIdentityApiV1IdentityIdentitiesIdentityIdDelete(identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère l\'historique d\'audit des opérations de bulk import.  Args:     user_id: Filtrer par utilisateur     establishment_id: Filtrer par établissement     batch_id: Filtrer par batch     limit: Limite du nombre de résultats
     * @summary Get Audit History
     * @param {string | null} [userId] 
     * @param {string | null} [establishmentId] 
     * @param {string | null} [batchId] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAuditHistoryApiV1IdentityBulkimportAuditGet(userId?: string | null, establishmentId?: string | null, batchId?: string | null, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAuditHistoryApiV1IdentityBulkimportAuditGet(userId, establishmentId, batchId, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère la progression d\'un batch d\'import.  Args:     batch_id: ID du batch
     * @summary Get Bulk Import Progress
     * @param {string} batchId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBulkImportProgressApiV1IdentityBulkimportProgressBatchIdGet(batchId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBulkImportProgressApiV1IdentityBulkimportProgressBatchIdGet(batchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère un template CSV pour un domaine donné.  Args:     domain: Domaine (student, parent, teacher, admin_staff)
     * @summary Get Csv Template
     * @param {string} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCsvTemplateApiV1IdentityBulkimportTemplateDomainGet(domain: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCsvTemplateApiV1IdentityBulkimportTemplateDomainGet(domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère une identité par son ID.  Args:     identity_id: ID de l\'identité     request: Requête HTTP     identity_crud_service: Service CRUD des identités      Returns:     IdentityResponse: Identité trouvée
     * @summary Get Identity
     * @param {string} identityId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getIdentityApiV1IdentityIdentitiesIdentityIdGet(identityId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getIdentityApiV1IdentityIdentitiesIdentityIdGet(identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère les statistiques des connexions SSE.  Returns:     Dict: Statistiques des connexions
     * @summary Get Sse Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSseStatsApiV1IdentityBulkimportSseStatsGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSseStatsApiV1IdentityBulkimportSseStatsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère la liste des établissements de l\'utilisateur connecté.  Source: identity_establishment(identity_id, establishment_id) Retourne 403 si aucun rattachement.  Args:     current_user: Utilisateur connecté     identity_crud_service: Service CRUD des identités      Returns:     UserEstablishmentsResponse: Liste des établissements avec leurs rôles
     * @summary Get User Establishments
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUserEstablishmentsApiV1IdentityMeEstablishmentsGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUserEstablishmentsApiV1IdentityMeEstablishmentsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Récupère les rôles de l\'utilisateur dans un établissement spécifique.  Source: identity_establishment.role (ENUM: student|parent|teacher|admin_staff) Retourne 403 si l\'utilisateur n\'est pas rattaché à l\'établissement.  Args:     etab: UUID de l\'établissement     current_user: Utilisateur connecté     identity_crud_service: Service CRUD des identités      Returns:     UserRolesResponse: Rôles de l\'utilisateur dans l\'établissement
     * @summary Get User Roles In Establishment
     * @param {string} etab UUID de l\&#39;établissement
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUserRolesInEstablishmentApiV1IdentityMeRolesGet(etab: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUserRolesInEstablishmentApiV1IdentityMeRolesGet(etab, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint de vérification de santé du service.
     * @summary Health Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public healthCheckHealthGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).healthCheckHealthGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lie une identité à un établissement.  Args:     identity_id: ID de l\'identité     link_data: Données du lien     request: Requête HTTP     identity_crud_service: Service CRUD des identités      Returns:     Dict: Message de confirmation
     * @summary Link Identity To Establishment
     * @param {string} identityId 
     * @param {EstablishmentLinkCreate} establishmentLinkCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public linkIdentityToEstablishmentApiV1IdentityIdentitiesIdentityIdEstablishmentsPost(identityId: string, establishmentLinkCreate: EstablishmentLinkCreate, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).linkIdentityToEstablishmentApiV1IdentityIdentitiesIdentityIdEstablishmentsPost(identityId, establishmentLinkCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Liste les identités avec pagination et filtres.  Args:     page: Numéro de page     size: Taille de la page     search: Terme de recherche global     sort_by: Champ de tri     sort_order: Ordre de tri     firstname: Filtre par prénom     lastname: Filtre par nom     email: Filtre par email     status: Filtre par statut     establishment_id: Filtre par établissement     role: Filtre par rôle     request: Requête HTTP     identity_crud_service: Service CRUD des identités      Returns:     IdentityListResponse: Liste paginée des identités
     * @summary List Identities
     * @param {number} [page] Numéro de page
     * @param {number} [size] Taille de la page
     * @param {string | null} [search] Terme de recherche global
     * @param {string | null} [sortBy] Champ de tri
     * @param {string | null} [sortOrder] Ordre de tri
     * @param {string | null} [firstname] Filtrer par prénom
     * @param {string | null} [lastname] Filtrer par nom
     * @param {string | null} [email] Filtrer par email
     * @param {string | null} [status] Filtrer par statut
     * @param {string | null} [establishmentId] Filtrer par établissement
     * @param {string | null} [role] Filtrer par rôle
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listIdentitiesApiV1IdentityIdentitiesGet(page?: number, size?: number, search?: string | null, sortBy?: string | null, sortOrder?: string | null, firstname?: string | null, lastname?: string | null, email?: string | null, status?: string | null, establishmentId?: string | null, role?: string | null, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listIdentitiesApiV1IdentityIdentitiesGet(page, size, search, sortBy, sortOrder, firstname, lastname, email, status, establishmentId, role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint racine pour vérifier que le service fonctionne.
     * @summary Root
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rootGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rootGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gestion des requêtes OPTIONS pour CORS.  Args:     batch_id: ID du batch      Returns:     Response: Headers CORS
     * @summary Sse Options
     * @param {string} batchId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public sseOptionsApiV1IdentityBulkimportStreamBatchIdOptions(batchId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).sseOptionsApiV1IdentityBulkimportStreamBatchIdOptions(batchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stream Server-Sent Events pour la progression d\'un batch.  Args:     batch_id: ID du batch à suivre     timeout: Timeout en secondes (5 minutes par défaut)     request: Requête HTTP     bulk_import_service: Service de bulk import      Returns:     StreamingResponse: Flux SSE de la progression
     * @summary Stream Batch Progress
     * @param {string} batchId 
     * @param {number | null} [timeout] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public streamBatchProgressApiV1IdentityBulkimportStreamBatchIdGet(batchId: string, timeout?: number | null, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).streamBatchProgressApiV1IdentityBulkimportStreamBatchIdGet(batchId, timeout, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Supprime le lien entre une identité et un établissement.  Args:     identity_id: ID de l\'identité     establishment_id: ID de l\'établissement     request: Requête HTTP     identity_crud_service: Service CRUD des identités      Returns:     Dict: Message de confirmation
     * @summary Unlink Identity From Establishment
     * @param {string} identityId 
     * @param {string} establishmentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public unlinkIdentityFromEstablishmentApiV1IdentityIdentitiesIdentityIdEstablishmentsEstablishmentIdDelete(identityId: string, establishmentId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).unlinkIdentityFromEstablishmentApiV1IdentityIdentitiesIdentityIdEstablishmentsEstablishmentIdDelete(identityId, establishmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Met à jour une identité.  Args:     identity_id: ID de l\'identité à mettre à jour     identity_data: Nouvelles données     request: Requête HTTP     identity_crud_service: Service CRUD des identités      Returns:     IdentityResponse: Identité mise à jour
     * @summary Update Identity
     * @param {string} identityId 
     * @param {IdentityUpdate} identityUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateIdentityApiV1IdentityIdentitiesIdentityIdPut(identityId: string, identityUpdate: IdentityUpdate, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateIdentityApiV1IdentityIdentitiesIdentityIdPut(identityId, identityUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



